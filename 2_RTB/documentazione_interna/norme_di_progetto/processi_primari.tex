\section{Processi primari}
\subsection{Fornitura}
\subsubsection{Introduzione}
Il processo di fornitura è un percorso strutturato che stabilisce un accordo contrattuale tra il fornitore e il cliente e guida lo sviluppo e la consegna di un prodotto software, dalla concezione iniziale fino alla manutenzione post-rilascio. Questo processo è fondamentale per garantire che il software soddisfi i requisiti del cliente, sia di alta qualità e venga consegnato nei tempi e nei costi previsti.
\subsubsection{Attività}
Il processo di fornitura comprende le fasi di seguito specificate.
\begin{itemize}
	\item \textbf{Preparazione della proposta}: questa fase iniziale prevede la raccolta di informazioni e la stesura di una proposta formale per il cliente. Si suddivide in:
	      \begin{itemize}
		      \item analisi delle esigenze del cliente;
		      \item studio di fattibilità;
		      \item elaborazione della proposta.
	      \end{itemize}
	\item \textbf{Contrattazione}: durante questa fase il fornitore e il cliente discutono e negoziano i termini del contratto. Alcune attività tipiche di questa fase includono:
	      \begin{itemize}
		      \item discussione dei termini e delle condizioni;
		      \item stesura e revisione del contratto;
		      \item firma del contratto.
	      \end{itemize}
	\item \textbf{Pianificazione}: fondamentale per organizzare e programmare le attività del progetto. Questa fase include:
	      \begin{itemize}
		      \item stesura delle milestone;
		      \item stesura del piano di progetto;
		      \item assegnazione dei compiti e delle risorse.
	      \end{itemize}
	\item \textbf{Esecuzione}: si effettua la realizzazione concreta del progetto, con la costruzione del prodotto software. L'attività è costituita principalmente da:
	      \begin{itemize}
		      \item sviluppo del software;
		      \item test e verifica;
		      \item documentazione.
	      \end{itemize}
	\item \textbf{Revisione}: prevede una valutazione approfondita del lavoro svolto per garantire che tutto sia conforme agli standard di qualità e ai requisiti contrattuali. Questa fase include:
	      \begin{itemize}
		      \item revisione del codice;
		      \item test di accettazione;
		      \item correzione delle discrepanze.
	      \end{itemize}
	\item \textbf{Consegna}: consiste, appunto, nella consegna del prodotto finale al cliente e nella preparazione per il supporto post-rilascio. Si compone di:
	      \begin{itemize}
		      \item consegna del software;
		      \item formazione del personale;
		      \item supporto post-rilascio.
	      \end{itemize}
\end{itemize}

\subsubsection{Contatti con l'azienda proponente}
\textit{SyncLab S.r.l.} offre un indirizzo email e un canale Discord per la comunicazione tramite messaggi, oltre a Google Meet per gli incontri telematici. Gli incontri online si terranno inizialmente con cadenza bisettimanale, con la possibilità di organizzare incontri extra su richiesta del gruppo. Per ogni colloquio con l’azienda proponente sarà redatto un verbale che riassumerà i temi trattati. Tali documenti saranno disponibili al seguente \href{https://7last.github.io/docs/category/verbali-esterni}{\underline{link}}.

\subsubsection{Documentazione fornita}
Di seguito saranno elencati i documenti che il gruppo \textit{7last} consegnerà all'azienda \textit{SyncLab S.r.l.} e ai committenti \textit{Prof. Tullio Vardanega} e \textit{Prof. Riccardo Cardin}.
\newpage

\subsubsubsection{Piano di qualifica}
Il \textit{Piano di Qualifica} è un documento che specifica le responsabilità e le attività del verificatore nel progetto, delineando le strategie e gli approcci adottati per garantire la qualità del prodotto software in fase di sviluppo. Redatto dal verificatore, questo documento descrive le modalità di verifica e validazione, nonché gli standard e le procedure di qualità da seguire durante l'intero ciclo di vita del progetto. Tutti i membri del team si riferiranno a questo documento per assicurarsi di raggiungere la qualità desiderata. Questo documento è organizzato in diverse sezioni, tra cui:
\begin{itemize}
	\item \textbf{qualità di processo}: definisce gli standard e le procedure adottate durante il progetto al fine di garantire che i processi seguiti siano di alta qualità;
	\item \textbf{qualità di prodotto}: stabilisce i criteri, le metriche e gli standard da rispettare affinchè il prodotto finale sia di alta qualità;
	\item \textbf{metodologie di testing}: contiene la descrizione di tutti i test necessari a verificare che il prodotto soddisfi i requisiti specificati;
	\item \textbf{cruscotto di valutazione della qualità}: riporta le attività di verifica svolte e le problematiche riscontrate durante lo sviluppo del software, con l'obiettivo di identificare aree di miglioramento;
	\item \textbf{iniziative di automiglioramento per la qualità}: contiene le azioni correttive e preventive adottate per migliorare la qualità del prodotto e dei processi.
\end{itemize}

\subsubsubsection{Analisi dei requisiti}
Questo documento, redatto dall'analista, offre una panoramica chiara delle richieste e delle aspettative dell'azienda proponente. Serve come guida per il team di sviluppo, fornendo un elenco dettagliato delle funzionalità da implementare e dei requisiti da soddisfare. Infine, durante le fasi di verifica e validazione, questo documento viene utilizzato come base di riferimento per garantire che il prodotto software sviluppato rispetti le richieste e le necessità degli utenti finali, contribuendo così al successo complessivo del progetto.
Il documento è composto principalmente dalle sezioni qui specificate.
\begin{itemize}
	\item \textbf{Descrizione}: fornisce una panoramica generale del progetto, del contesto in cui il software verrà utilizzato e degli obiettivi principali. Include una spiegazione chiara dello scopo del documento e delle sue finalità.
	\item \textbf{Elenco dei casi d'uso}: riporta tutti gli scenari possibili in cui il sistema software potrebbe essere utilizzato dagli utenti finali. Ogni caso d'uso descrive dettagliatamente le azioni che gli utenti compiono nel sistema, permettendo di identificare requisiti non ovvi inizialmente. Questa sezione fornisce una visione dettagliata delle interazioni previste tra gli utenti e il sistema, contribuendo a definire le funzionalità e le caratteristiche del software.
	\item \textbf{Elenco dei requisiti}: specifica tutti i vincoli richiesti dalla proponente o dedotti in base all'analisi dei casi d'uso associati ad essi. I requisiti delineano le funzionalità, le prestazioni, le restrizioni e altri aspetti critici del software che devono essere soddisfatti. Essi rappresentano le basi su cui il team progetta e implementa il software, assicurando che il prodotto finale rispetti le aspettative degli stakeholder e soddisfi le necessità degli utenti finali.
\end{itemize}

\subsubsubsection{Piano di progetto}
Redatto dal responsabile, delinea in modo dettagliato e organizzato tutti gli aspetti e le attività coinvolte nella gestione di un progetto di sviluppo del software. Esso funge da strumento di pianificazione, monitoraggio e controllo, offrendo una visione chiara e ben definita per il team di progetto. Il documento è costituito principalmente dalle sezioni qui elencate.
\begin{itemize}
	\item \textbf{Analisi dei rischi}: identificazione delle problematiche che potrebbero insorgere durante il processo e che potrebbero arrecare ritardi o impedimenti nella progressione del progetto. Il gruppo si impegna a fornire soluzioni per tali problemi il prima possibile. I rischi sono classificati in tre categorie principali: rischi organizzativi, rischi tecnologici e rischi comunicativi.
	\item \textbf{Calendario di progetto}: definisce le tempistiche pianificate per le varie revisioni previste durante lo svolgimento del progetto.
	\item \textbf{Stima costi realizzazione}: espone una previsione dettagliata dei costi di realizzazione del progetto.
	\item \textbf{Gestione del modello e sprint}: definisce i periodi temporali con eventi e attività correlate, all'interno di un calendario. Per ciascun periodo vengono analizzati i rischi, i costi e le attività sia in fase di pianificazione che in fase di retrospettiva.
\end{itemize}


\subsubsubsection{Glossario}
Il \textit{Glossario} è un elenco dettagliato e organizzato di termini, acronimi e definizioni utilizzati nel contesto del progetto. Fornisce una chiara comprensione dei concetti e dei termini specifici impiegati nel progetto, garantendo una comunicazione efficace e coesa tra tutti i membri del team, nonché con gli stakeholder.

\subsubsubsection{Lettera di presentazione}
La \textit{Lettera di Presentazione} costituisce il mezzo attraverso il quale il gruppo \textit{7Last} espone il proprio interesse a partecipare attivamente alla fase di revisione del prodotto software. Questo documento non solo mette in luce la disponibilità della documentazione rilevante per i committenti e la proponente, ma stabilisce anche i termini concordati per la consegna del prodotto finito.

\subsubsection{Metriche}
\begin{table}[!h]
	\centering
	\begin{tabular}{ | c | l | }
		\hline
		\textbf{Codice}                       & \textbf{Nome esteso}       \\
		\hline
		\underline{\hyperlink{1M}{1M-PV}}     & Planned Value              \\
		\underline{\hyperlink{2M}{2M-EV}}     & Earned Value               \\
		\underline{\hyperlink{3M}{3M-AC}}     & Actual Cost                \\
		\underline{\hyperlink{4M}{4M-SV}}     & Schedule Variance          \\
		\underline{\hyperlink{5M}{5M-CV}}     & Cost Variance              \\
		\underline{\hyperlink{6M}{6M-CPI}}    & Cost Performance Index     \\
		\underline{\hyperlink{7M}{7M-SPI}}    & Schedule Performance Index \\
		\underline{\hyperlink{8M}{8M-EAC}}    & Estimate at Completion     \\
		\underline{\hyperlink{9M}{9M-ETC}}    & Estimate to Complete       \\
		\underline{\hyperlink{10M}{10M-OTDR}} & On Time Delivery Rate      \\
		\hline
	\end{tabular}
	\caption{Metriche inerenti il processo di Fornitura}
\end{table}

\subsubsection{Strumenti}
Di seguito sono descritti gli strumenti software impiegati nel processo di fornitura:
\begin{itemize}
	\item \textbf{Discord} come piattaforma per le riunioni interne e metodo informale per contattare l'azienda proponente tramite messaggistica;
	\item \textbf{Google Meet} utilizzato per le riunioni con la proponente;
	\item \textbf{Google Slides} come strumento per la creazione di presentazioni;
	\item \textbf{LaTeX} come sistema di preparazione di documenti utilizzato principalmente per la creazione di documenti tecnici e scientifici;
	\item \textbf{ClickUp} come strumento di gestione del progetto per la pianificazione e il monitoraggio delle attività.
\end{itemize}

\subsection{Sviluppo}
\subsubsection{Introduzione}
Lo standard \textit{ISO/IEC 12207:1995} fornisce un quadro completo e strutturato per la gestione del ciclo di vita del software. Definisce i processi, le attività e le mansioni coinvolte nello sviluppo, nell'acquisizione e nella manutenzione del software.
È fondamentale completare tali operazioni in stretto rispetto alle direttive e ai requisiti definiti nel contratto con il cliente, assicurando quindi una realizzazione precisa e in linea con le specifiche richieste.

\subsubsection{Analisi dei requisiti}
\subsubsubsection{Descrizione}
Ha lo scopo di identificare, definire e documentare in modo esaustivo le necessità, le funzionalità e le prestazioni che il sistema software deve soddisfare. Questo documento rappresenta il punto di partenza per il processo di sviluppo del software, fornendo una base solida e chiara per la progettazione, l'implementazione e la verifica del sistema. Attraverso l'analisi dei requisiti, si cerca di comprendere appieno le esigenze degli stakeholder, inclusi utenti finali e clienti, al fine di garantire che il prodotto software sviluppato soddisfi le loro aspettative e necessità. L'analisi dei requisiti include tipicamente la raccolta e la documentazione dei requisiti funzionali di vincolo e qualitativi, la definizione dei casi d'uso nonché la prioritizzazione e la tracciabilità dei requisiti lungo l'intero ciclo di vita del software.
\newpage
\subsubsubsection{Scopo}
Questo processo pone i seguenti obiettivi principali:
\begin{itemize}
	\item promuovere una comprensione condivisa tra tutte le parti interessate;
	\item consentire una stima accurata delle tempistiche e dei costi del progetto;
	\item fornire ai progettisti requisiti chiari e facilmente comprensibili;
	\item definire gli obiettivi del prodotto al fine di soddisfare le aspettative;
	\item agevolare l'attività di verifica e di test fornendo indicazioni pratiche di riferimento.
\end{itemize}
\subsubsubsection{Documentazione}
Gli analisti hanno il compito di redigere l'\textit{Analisi dei Requisiti}, comprendendo le seguenti sezioni:
\begin{itemize}
	\item \textbf{introduzione}, contente la presentazione e lo scopo del documento stesso;
	\item \textbf{descrizione del prodotto}, in cui è definita un'analisi approfondita del prodotto, includendo:
	      \begin{itemize}
		      \item obiettivi del prodotto;
		      \item architettura del prodotto;
		      \item funzionalità del prodotto;
		      \item caratteristiche degli utenti;
	      \end{itemize}
	\item \textbf{casi d'uso} con le descrizioni delle funzionalità offerte dal sistema dal punto di vista dell'utente, includendo:
	      \begin{itemize}
		      \item attori coinvolti;
		      \item elenco dei casi d'uso
	      \end{itemize}
	\item \textbf{requisiti}, suddivisi in:
	      \begin{itemize}
		      \item funzionali;
		      \item qualitativi;
		      \item di vincolo.
	      \end{itemize}
\end{itemize}

\subsubsubsection{Casi d'uso}
I casi d'uso forniscono una descrizione dettagliata delle funzionalità del sistema dal punto di vista degli utenti, delineando come il sistema risponda a specifiche azioni o scenari. Ogni caso d'uso deve includere:
\begin{itemize}
	\item \textbf{identificativo}:
	      \begin{center}
		      \textbf{UC-[identificativo\_caso\_principale].[identificativo\_sotto\_caso]}
	      \end{center}
	      \begin{itemize}
		      \item \textbf{identificativo sotto caso}: identificativo numerico del sotto caso d'uso (presente solo se si tratta di un sotto caso d'uso);
		      \item \textbf{titolo}: breve e chiaro titolo del caso d'uso;
	      \end{itemize}
	\item \textbf{attore principale}: entità esterna che interagisce attivamente con il sistema per soddisfare una propria necessità;
	\item \textbf{precondizioni}: lo stato in cui deve trovarsi il sistema affinché la funzionalità sia disponibile per l'attore;
	\item \textbf{postcondizioni}: lo stato in cui si trova il sistema dopo l'esecuzione dello scenario principale;
	\item \textbf{scenario principale}: una sequenza di eventi che si verificano quando un attore interagisce con il sistema per raggiungere l'obiettivo del caso d'uso (postcondizioni);
	\item \textbf{user story}: una breve descrizione di una funzionalità del software, scritta dal punto di vista dell'utente, che fornisce contesto, obiettivi e valore:
	      \begin{itemize}
		      \item L'user story viene scritta nella forma: "Come [utente] desidero poter [funzionalità] per [valore aggiunto]";
	      \end{itemize}
\end{itemize}

\subsubsubsection{Diagrammi dei casi d'uso}
Offrono una rappresentazione visiva delle interazioni tra gli attori e il sistema, delineando i vari scenari in cui esso verrà utilizzato. Ogni caso d'uso descrive una sequenza specifica di azioni che gli attori compiono per raggiungere un obiettivo particolare all'interno del sistema. I diagrammi dei casi d'uso aiutano a identificare i requisiti funzionali, fornendo una comprensione chiara e condivisa delle aspettative degli utenti. Inoltre, facilitano la comunicazione tra gli sviluppatori e gli stakeholder, assicurando che tutte le funzionalità necessarie siano considerate e correttamente implementate nell'applicativo.
Di seguito vengono elencati i principali componenti di un diagramma dei casi d'uso.
\begin{itemize}
	\item \textbf{Sistema}: delimita i confini del sistema software, indicando quali funzionalità sono incluse e quali sono esterne ad esso.
	      \begin{center}
		      \includegraphics*[width=8cm]{../../../images/norme_di_progetto/sistema.png}
		      \captionof{figure}{Diagramma dei casi d'uso - sistema}
	      \end{center}
	\item \textbf{Attori}: rappresentano soggetti che interagiscono con il sistema software. Gli attori possono essere persone, altri applicativi o dispositivi che utilizzano le funzionalità del sistema.
	      \begin{center}
		      \includegraphics*[width=2.5cm]{../../../images/norme_di_progetto/attore.png}
		      \captionof{figure}{Diagramma dei casi d'uso - attore}
	      \end{center}
	\item \textbf{Casi d'uso}: rappresentano le funzionalità o i servizi offerti dal sistema che producono un risultato di valore per un attore. Ogni caso d'uso descrive una sequenza specifica di interazioni tra gli attori e il sistema.
	      \begin{center}
		      \includegraphics*[width=6cm]{../../../images/norme_di_progetto/uc.png}
		      \captionof{figure}{Diagramma dei casi d'uso - caso d'uso}
	      \end{center}
	\item \textbf{Sottocasi d'uso}: rappresentano scenari specifici e dettagliati che si verificano all'interno di un caso d'uso principale, descrivendolo in modo più dettagliato.
	      \begin{center}
		      \includegraphics*[width=8cm]{../../../images/norme_di_progetto/sottocasi.png}
		      \captionof{figure}{Diagramma dei casi d'uso - sottocaso d'uso}
	      \end{center}

	\item \textbf{Relazioni tra Attori e Casi d'Uso}
	      \begin{itemize}
		      \item \textbf{Associazione}: è la relazione fondamentale che collega un attore a un caso d'uso, indica quali attori interagiscono con quali casi d'uso.
		            \begin{center}
			            \includegraphics*[width=8cm]{../../../images/norme_di_progetto/associazione.png}
			            \captionof{figure}{Diagramma dei casi d'uso - associazione}
		            \end{center}
	      \end{itemize}

	\item \textbf{Relazioni tra Attori}
	      \begin{itemize}
		      \item \textbf{Generalizzazione}: rappresenta una relazione in cui un attore figlio condivide almeno le funzionalità di un attore genitore. Utilizzata quando diversi attori condividono comportamenti comuni.
		            \begin{center}
			            \includegraphics*[width=1.5cm]{../../../images/norme_di_progetto/generalizzazione_attori.png}
			            \captionof{figure}{Diagramma dei casi d'uso - generalizzazione tra attori}
		            \end{center}
	      \end{itemize}

	\item \textbf{Relazioni tra Casi d'Uso}
	      \begin{itemize}
		      \item \textbf{Inclusione}: rappresenta una dipendenza in cui il comportamento del caso d'uso incluso è incorporato ogni volta che viene eseguito il caso d'uso base. Il caso d'uso incluso contiene funzionalità che sono riutilizzate in più casi d'uso principali, permettendo di evitare la duplicazione di comportamenti comuni.
		            \begin{center}
			            \includegraphics*[width=7cm]{../../../images/norme_di_progetto/include.png}
			            \captionof{figure}{Diagramma dei casi d'uso - inclusione}
		            \end{center}
		      \item \textbf{Estensione}: mostra una relazione in cui un caso d'uso esteso aumenta le funzionalità del caso d'uso principale. Il caso d'uso esteso viene eseguito solo sotto determinate condizioni, interrompendo l'esecuzione del caso d'uso principale.
		            \begin{center}
			            \includegraphics*[width=8cm]{../../../images/norme_di_progetto/estensione.png}
			            \captionof{figure}{Diagramma dei casi d'uso - estensione}
		            \end{center}
		      \item \textbf{Generalizzazione}: rappresenta una relazione in cui un caso d'uso figlio può aggiungere funzionalità o modificare il comportamento di un caso d'uso genitore. Tutte le funzionalità definite nel caso d'uso genitore si mantengono nel caso d'uso figlio se queste non vengono ridefinite.
		            \begin{center}
			            \includegraphics*[width=9cm]{../../../images/norme_di_progetto/generalizzazione_uc.png}
			            \captionof{figure}{Diagramma dei casi d'uso - generalizzazione tra casi d'uso}
		            \end{center}
	      \end{itemize}


\end{itemize}

\subsubsubsection{Requisiti}
Delineano una descrizione dettagliata delle funzionalità e delle caratteristiche che il software deve possedere per soddisfare le esigenze degli utenti e degli stakeholder. Questi requisiti costituiscono la base per tutto il ciclo di sviluppo del software e sono fondamentali per il successo del progetto. Si suddividono generalmente in tre categorie principali:
\begin{itemize}
	\item \textbf{requisiti funzionali}, i quali descrivono le azioni specifiche che il sistema deve essere in grado di eseguire;
	\item \textbf{requisiti non funzionali}, che definiscono le proprietà e le caratteristiche del sistema che ne influenzano il funzionamento e l'uso;
	\item \textbf{requisiti di vincolo}, che rappresentano i vincoli e le restrizioni che il sistema deve rispettare.
\end{itemize}
Ogni requisito è costituito da:
\begin{enumerate}
	\item \textbf{codice}: i requisiti sono codificati nel seguente modo:
	      \begin{center}
		      \textbf{R[Tipologia]-[Codice]}
	      \end{center}
	      dove
	      \begin{itemize}
		      \item \textbf{[Tipologia]}: indica la tipologia del requisito, che può essere:
		            \begin{itemize}
			            \item \textbf{F}: requisito funzionale;
			            \item \textbf{Q}: requisito di qualità;
			            \item \textbf{V}: requisito di vincolo.
		            \end{itemize}
		      \item \textbf{[Codice]}: è un numero progressivo che identifica univocamente il requisito.
	      \end{itemize}
	\item \textbf{Importanza}: indica il grado di importanza del requisito, che può essere:
	      \begin{itemize}
		      \item \textbf{Obbligatorio}: irrinunciabile per il \href{https://7last.github.io/docs/rtb/documentazione-interna/glossario\#committente}{committente\textsubscript{G}};
		      \item \textbf{Desiderabile}: non strettamente necessario, ma che porta valore aggiunto al prodotto;
		      \item \textbf{Opzionale}: relativo a funzionalità aggiuntive.
	      \end{itemize}
	\item \textbf{Fonte}: indica la fonte da cui è stato identificato il requisito, che può essere:
	      \begin{itemize}
		      \item \href{https://7last.github.io/docs/rtb/documentazione-interna/glossario\#capitolato}{\textbf{capitolato}\textsubscript{G}}: requisiti individuati a seguito dell'analisi dello stesso;
		      \item \textbf{interno}: requisiti individuati durante le riunioni interne e da coloro che hanno il ruolo di analista;
		      \item \textbf{esterno}: requisiti aggiuntivi individuati in seguito a incontri con la \href{https://7last.github.io/docs/rtb/documentazione-interna/glossario\#proponente}{proponente\textsubscript{G}};
		      \item \href{https://7last.github.io/docs/rtb/documentazione-interna/glossario\#piano-di-qualifica}{\textbf{piano di qualifica}\textsubscript{G}}: requisiti necessari per adeguare il prodotto agli standard di qualità definiti nel documento \href{https://7last.github.io/docs/rtb/documentazione-interna/glossario\#piano-di-qualifica}{\textit{Piano di Qualifica}\textsubscript{G}};
		      \item \href{https://7last.github.io/docs/rtb/documentazione-interna/glossario\#norme-di-progetto}{\textbf{norme di progetto}\textsubscript{G}}: requisiti necessari per adeguare il prodotto alle norme stabilite nel documento \href{https://7last.github.io/docs/rtb/documentazione-interna/glossario\#norme-di-progetto}{\textit{Norme di Progetto}\textsubscript{G}}.
	      \end{itemize}
\end{enumerate}

\subsubsubsection{Metriche}
Nell'analisi dei requisiti, le metriche sono strumenti utilizzati per misurare vari aspetti del processo di sviluppo e del prodotto finale. All'interno di un'analisi dei requisiti, le metriche svolgono un ruolo cruciale nel garantire che il software sia sviluppato in modo efficiente, soddisfi gli standard di qualità attesi e adempia alle specifiche richieste dagli stakeholder.
\begin{table}[!h]
	\centering
	\begin{tabular}{ | c | l | }
		\hline
		\textbf{Codice}                      & \textbf{Nome esteso}               \\
		\hline
		\underline{\hyperlink{11M}{11M-PRO}} & Percentuale requisiti obbligatori  \\
		\underline{\hyperlink{12M}{12M-PRD}} & Percentuale requisiti desiderabili \\
		\underline{\hyperlink{13M}{13M-PRO}} & Percentuale requisiti opzionali    \\
		\hline
	\end{tabular}
	\caption{Metriche inerenti i Requisiti}
\end{table}

\subsubsubsection{Strumenti}
\textbf{Draw.io} è uno strumento online che permette di creare diagrammi dei casi d'uso in modo semplice e intuitivo. Questo strumento offre una vasta gamma di funzionalità e opzioni di personalizzazione per creare diagrammi chiari e ben strutturati. Draw.io è un'applicazione web-based, quindi non richiede alcun download o installazione, rendendo facile e veloce la creazione di diagrammi dei casi d'uso.

\subsubsection{Progettazione}
\subsubsubsection{Descrizione}
L'attività di progettazione svolge un ruolo fondamentale nello sviluppo del software, consentendo di definire l'architettura, i componenti e le interfacce del sistema in modo da soddisfare i requisiti definiti durante l'analisi.  Questa fase si basa sull'analisi dei requisiti e ha lo scopo di tradurre i requisiti funzionali e non funzionali in una soluzione tecnica implementabile.

\subsubsubsection{Obiettivi}
L'obiettivo principale è soddisfare i requisiti attraverso un sistema di qualità definito dall'architettura del prodotto.
\begin{itemize}
	\item \textbf{Definizione dell'architettura}: in questa fase si definisce l'architettura del sistema, determinando la struttura generale, i componenti principali e le relazioni tra di essi. Questo include la scelta delle tecnologie, dei linguaggi di programmazione e delle piattaforme da utilizzare.
	\item \textbf{Suddivisione in moduli}: si suddivide il sistema in moduli o componenti più piccoli e gestibili, ciascuno con responsabilità specifiche. Questa suddivisione facilita lo sviluppo, il testing e la manutenzione del software.
	\item \textbf{Definizione delle interfacce}: si specificano le interfacce tra i diversi moduli o componenti del sistema, stabilendo come essi comunicano e interagiscono tra di loro. Questo garantisce una corretta integrazione e interoperabilità del sistema.
	\item \textbf{Identificazione delle risorse}: vengono identificate le risorse necessarie per implementare il sistema, come hardware, software, risorse umane e finanziarie. Questo aiuta a pianificare e gestire le risorse in modo efficace durante lo sviluppo.
	\item \textbf{Valutazione delle prestazioni}: si valutano le prestazioni del sistema, identificando potenziali problemi di scalabilità, affidabilità e prestazioni. Questo consente di ottimizzare il design per garantire che il sistema soddisfi i requisiti di prestazione.
\end{itemize}

\begin{flushleft}
	Lo sviluppo del progetto inizia con l'analisi delle tecnologie suggerite dalla proponente e un confronto con eventuali alternative, valutando i pro e i contro di ciascuna. Dopo aver selezionato le tecnologie più adatte, si procede con lo sviluppo di un Proof of Concept (PoC), un prototipo grezzo che dimostra l'idoneità delle tecnologie scelte e la capacità del team di utilizzarle efficacemente. Questo PoC costituisce la componente principale della Technology Baseline, che funge da base per lo sviluppo del prodotto finale. A partire da questa, si procede con lo sviluppo del prodotto vero e proprio, trasformando il PoC in un Minimum Viable Product (MVP), ovvero un prodotto minimale che soddisfa i requisiti minimi richiesti e che diventerà parte integrante della Product Baseline (PB).
\end{flushleft}

\subsubsubsection{Documentazione}
\textbf{Specifica tecnica}\\
Fornisce una guida dettagliata ed esaustiva per la progettazione e lo sviluppo del sistema. In essa sono delineate con precisione l'architettura tecnica del software, con tutti i suoi componenti e interfacce, le funzionalità che il sistema dovrà offrire e le tecnologie che saranno impiegate per realizzarlo. Questo documento costituisce il punto di partenza per l'intero ciclo di sviluppo del software, fornendo una base solida e strutturata su cui il team di sviluppo potrà lavorare in modo efficace ed efficiente. Tra gli elementi chiave inclusi in questo documento vi sono:
\begin{itemize}
	\item \textbf{architettura del sistema}: questa sezione delinea l'architettura generale del sistema software, identificando i principali componenti, i moduli e le interfacce. Include anche informazioni sull'organizzazione logica e fisica del sistema, come ad esempio la suddivisione in livelli o strati e le relazioni tra di essi;
	\item \textbf{tecnologie utilizzate}: specifica le tecnologie, i linguaggi di programmazione, i framework e le librerie che saranno impiegate nello sviluppo del sistema. Questo include anche eventuali tool e ambienti di sviluppo adottati;
	\item \textbf{struttura dei dati}: descrive la struttura e la gestione dei dati all'interno del sistema, inclusi database, file system, protocolli di accesso ai dati e modelli di persistenza;
	\item \textbf{interfacce esterne}: indica le interfacce con altri sistemi o applicazioni esterne con cui il sistema deve interagire. Questo include anche la definizione dei formati dei dati scambiati e i protocolli di comunicazione utilizzati;
	\item \textbf{design pattern}: descrizione dei design pattern utilizzati per risolvere problemi comuni e ricorrenti durante lo sviluppo del software;
	\item \textbf{pianificazione e risorse}: fornisce una pianificazione dettagliata del lavoro da svolgere per implementare la specifica tecnica, inclusi tempi, costi e risorse necessarie;
	\item \textbf{procedure di testing e validazione}: indicazioni sulle procedure e gli strumenti da utilizzare per verificare e validare il prodotto, garantendo che soddisfi i requisiti e le aspettative del cliente;
	\item \textbf{requisiti tecnici}: elenco dettagliato dei requisiti tecnici che il prodotto deve soddisfare, con indicazioni sulle funzionalità, le prestazioni e le caratteristiche richieste;
	      % \item \textbf{sicurezza e privacy}: specifica i requisiti e le misure di sicurezza che saranno implementati nel sistema per proteggere i dati sensibili e garantire la privacy degli utenti. %todo: da approfondire
\end{itemize}

\subsubsubsection{Qualità dell'architettura}
\begin{itemize}
	\item \textbf{Scalabilità}: rappresenta la capacità del sistema di gestire un aumento del carico di lavoro o delle risorse senza compromettere le prestazioni o la qualità del servizio. Un'architettura scalabile può adattarsi dinamicamente alle variazioni delle richieste degli utenti e delle risorse disponibili.
	\item \textbf{Flessibilità}: capacità del sistema di adattarsi ai cambiamenti nei requisiti o nell'ambiente operativo senza richiedere modifiche significative. Un'architettura flessibile è caratterizzata da componenti ben separati e interfacce standardizzate, che consentono una facile modifica e l'aggiunta di nuove funzionalità.
	      % \item \textbf{sicurezza}: protezione dei dati, delle risorse e del sistema da minacce esterne e interne. Un'architettura sicura include meccanismi di autenticazione, autorizzazione, crittografia e controllo degli accessi per garantire la riservatezza, l'integrità e la disponibilità delle informazioni;
	\item \textbf{Manutenibilità}: ovvero la facilità di comprendere, modificare e correggere il software nel corso del suo ciclo di vita. Un'architettura manutenibile è caratterizzata da un codice ben strutturato, documentato e modularizzato, che consente agli sviluppatori di individuare e risolvere rapidamente eventuali problemi.
	\item \textbf{Testabilità}: facilità di testare il software per garantire che soddisfi i requisiti funzionali e non funzionali. Un'architettura testabile include componenti ben isolati e interfacce chiare che consentono l'automazione dei test e la verifica continua della qualità del software.
	\item \textbf{Affidabilità}: garanzia del corretto funzionamento del sistema in condizioni normali e anomale. Un'architettura affidabile include meccanismi di gestione degli errori, di recupero e di ripristino che consentono al sistema di continuare a operare in modo affidabile anche in presenza di guasti o interruzioni.
	\item \textbf{Performance}: capacità del sistema di fornire risposte rapide e tempi di elaborazione efficienti anche in presenza di carichi di lavoro elevati. Un'architettura performante include ottimizzazioni del codice, della gestione delle risorse e dell'accesso ai dati per massimizzare le prestazioni del sistema.
	\item \textbf{Usabilità}: facilità di utilizzo e comprensione del sistema da parte degli utenti finali. Un'architettura usabile include un'interfaccia utente intuitiva, una struttura di navigazione chiara e una presentazione coerente delle informazioni per garantire un'esperienza utente positiva.
	\item \textbf{Compatibilità}: capacità del sistema di interoperare con altri sistemi, piattaforme o tecnologie senza problemi. Un'architettura compatibile include standard aperti, interfacce ben definite e protocolli di comunicazione standardizzati che consentono l'integrazione con sistemi esterni.
	\item \textbf{Documentazione}: fornitura di documentazione completa e accurata sull'architettura del sistema, inclusi diagrammi, specifiche tecniche, manuale utente e guide per gli sviluppatori. Una buona documentazione facilita la comprensione, la manutenzione e l'evoluzione del sistema nel tempo.
	\item \textbf{Safety}: l'architettura deve garantire la sicurezza del sistema, in modo che possa proteggere i dati e le informazioni sensibili in seguito a malfunzionamenti.
\end{itemize}

\subsubsubsection{Diagrammi UML}
\begin{itemize}
	\item \textbf{Chiarezza visiva}: forniscono una rappresentazione visuale chiara e intuitiva delle relazioni e delle interazioni tra gli elementi del sistema software, facilitando la comprensione del sistema da parte degli stakeholder.
	\item \textbf{Standardizzazione}: UML è uno standard riconosciuto a livello internazionale per la modellazione dei sistemi software, il che significa che i diagrammi UML sono facilmente comprensibili da parte di professionisti del settore in tutto il mondo.
	\item \textbf{Comunicazione efficace}: forniscono un linguaggio comune per la comunicazione tra gli sviluppatori, gli stakeholder tecnici e non tecnici e altri membri del team, consentendo una comunicazione più efficace e una condivisione delle informazioni più chiara.
	\item \textbf{Analisi e progettazione}: possono essere utilizzati durante le fasi di analisi e progettazione del ciclo di sviluppo del software per visualizzare e analizzare i requisiti, le relazioni tra i componenti e le interazioni del sistema.
	\item \textbf{Modellazione e requisiti}: UML consente di modellare i requisiti del sistema in modo chiaro e strutturato, identificando casi d'uso, scenari e vincoli che guidano lo sviluppo del software.
	\item \textbf{Facilità di manutenzione}: è più facile comprendere l'architettura del sistema e individuare eventuali problemi o aree di miglioramento, facilitando così la manutenzione e l'evoluzione del software nel tempo.
	\item \textbf{Supporto agli standard di progettazione}: i diagrammi UML possono essere utilizzati per applicare e comunicare i principi di progettazione software ben consolidati, come l'incapsulamento, l'ereditarietà e il polimorfismo.
	\item \textbf{Documentazione}: possono essere utilizzati per generare documentazione tecnica dettagliata sul sistema software, fornendo una guida completa per gli sviluppatori, gli utenti finali e gli altri stakeholder.
\end{itemize}

% \subsubsubsubsection{Diagrammi delle Classi}
% Un tipo di diagramma UML ampiamente utilizzato nel processo di progettazione del software è il diagramma delle classi, che rappresenta la struttura statica del sistema, mostrando le classi, gli attributi, i metodi e le relazioni tra di esse. Le classi sono rappresentate da rettangoli suddivisi in tre sezioni:
% \begin{enumerate}
% 	\item \textbf{Nome della classe}: indica il nome della classe;
% 	\item \textbf{Attributi}: elenco degli attributi della classe, con il relativo tipo di dato, seguendo il formato: 
% 	\begin{center}
% 		\textbf{Visibilità Nome: Tipo [Molteplicità] = Valore di default}\end{center}
% 	      \begin{itemize}
% 		      \item \textbf{Visibilità}: indica il livello di accesso agli attributi, che può essere:
% 		            \begin{itemize}
% 			            \item \textbf{+}: pubblico;
% 			            \item \textbf{-}: privato;
% 			            \item \textbf{\#}: protetto;
% 			            \item \textbf{\textasciitilde}: package.
% 		            \end{itemize}
% 		      \item \textbf{Nome}: nome dell'attributo. Deve essere rappresentativo, chiaro e deve seguire la notazione \textit{nomeAttributo: tipo}; \\ Se l'attributo è costante, il nome deve essere scritto in maiuscolo (es. \textit{PIGRECO: double});
% 		      \item \textbf{Molteplicità}: nel caso di una sequenza di elementi come liste o array, indica il numero di elementi presenti, se questa non fosse conosciuta si utilizza il simbolo \textit{*} (es \textit{tipoAttributo[*]});
% 		      \item \textbf{default}: valore di default dell'attributo.
% 	      \end{itemize}
% 	\item \textbf{Metodi}: descrivono il comportamento della classe, seguendo il formato: \\ \begin{center}\textbf{Visibilità Nome(parametri): Tipo di ritorno}\end{center}
% 	      \begin{itemize}
% 		      \item \textbf{Visibilità}: indica il livello di accesso ai metodi, che può essere:
% 		            \begin{itemize}
% 			            \item \textbf{+}: pubblico;
% 			            \item \textbf{-}: privato;
% 			            \item \textbf{\#}: protetto;
% 			            \item \textbf{\textasciitilde}: package.
% 		            \end{itemize}
% 		      \item \textbf{Nome}: nome del metodo. Deve essere rappresentativo, chiaro e deve seguire la notazione \textit{nomeMetodo(parametri): tipoRitorno};
% 		      \item \textbf{Parametri}: elenco dei parametri del metodo, separati tramite virgola. Ogni parametro deve seguire la notazione \textit{nomeParametro: tipo};
% 		      \item \textbf{Tipo di ritorno}: indica il tipo di dato restituito dal metodo.
% 	      \end{itemize}
% \end{enumerate}

% \textbf{Convenzioni sui metodi}
% \begin{itemize}
% 	\item \textbf{I metodi getter, setter} e i \textbf{costruttori} non vengono inclusi fra i metodi;
% 	\item \textbf{I metodi statici} sono sottolineati;
% 	\item \textbf{I metodi astratti} sono scritti in corsivo.
% 	\item \textbf{L'assenza di attributi o metodi} in una classe determina l'assenza delle relative sezioni nel diagramma.
% \end{itemize}
% \textbf{Relazioni tra le classi}\\
% Essenziali per rappresentare le interazioni e le dipendenze tra le varie componenti del sistema software, queste relazioni forniscono un quadro completo della struttura e del comportamento del sistema, consentendo agli sviluppatori di comprendere meglio come le classi si relazionano tra loro e di progettare un sistema coerente e ben strutturato. Di seguito sono descritte le principali relazioni tra le classi:
% \begin{itemize}
% 	\item \textbf{Associazione}:  rappresenta una relazione tra due classi, indicando che un'istanza di una classe è correlata a un'istanza di un'altra classe. È raffigurata da una linea solida tra le classi coinvolte. La linea può includere etichette per indicare il nome dell'associazione, nonché molteplicità e ruoli per specificare la cardinalità e il ruolo delle classi nell'associazione.
% 		\begin{center}
% 			\includegraphics*[width=12cm]{../../../images/norme_di_progetto/associazioneClassi.png}
% 			\captionof{figure}{Diagramma delle classi - Associazione}
% 		\end{center}
% 	\newpage
% 	\item \textbf{Aggregazione}:  indica una relazione "tutto-parte" tra due classi, dove una classe è composta da una o più istanze di un'altra classe, ma le istanze possono esistere indipendentemente dalla classe principale. Composta da una linea con una freccia vuota che punta dalla parte composta (parte) al tutto (oggetto principale). La linea può includere un rombo vuoto sulla parte composta per indicare l'aggregazione.
% 		\begin{center}
% 			\includegraphics*[width=12cm]{../../../images/norme_di_progetto/aggregazioneClassi.png}
% 			\captionof{figure}{Diagramma delle classi - Aggregazione}
% 		\end{center}
% 	\item \textbf{Composizione}: simile all'aggregazione, ma indica una relazione più forte in cui l'esistenza delle parti dipende direttamente dall'oggetto principale. Una composizione è rappresentata da una linea con una freccia piena che punta dalla parte composta (parte) al tutto (oggetto principale). La linea può includere un rombo pieno sulla parte composta per indicare la composizione.
% 		\begin{center}
% 			\includegraphics*[width=10cm]{../../../images/norme_di_progetto/composizioneClassi.png}
% 			\captionof{figure}{Diagramma delle classi - Composizione}
% 		\end{center}
% 	\newpage
% 	\item \textbf{Ereditarietà o generalizzazione}: indica una relazione di specializzazione tra una classe superiore (superclasse) e una o più classi inferiori (sottoclassi). Le sottoclassi ereditano gli attributi e i metodi della superclasse e possono estenderli o modificarli. Viene effigiata da una linea con una freccia che punta dalla sottoclasse alla superclasse. La linea può includere una freccia vuota con la scritta "extends" per indicare la generalizzazione.
% 		\begin{center}
% 			\includegraphics*[width=10cm]{../../../images/norme_di_progetto/generalizzazioneClassi.png}
% 			\captionof{figure}{Diagramma delle classi - Generalizzazione}
% 		\end{center}
% 	\item \textbf{Dipendenza}: indica che una classe dipende dall'altra in un certo modo. Questo può significare che una classe utilizza o richiede i servizi di un'altra classe, ma non c'è un legame diretto tra le loro istanze. Una dipendenza è rappresentata da una linea tratteggiata che parte dalla classe dipendente e punta alla classe di cui dipende. La linea può includere una freccia vuota per indicare la direzione della dipendenza.
% 		\begin{center}
% 			\includegraphics*[width=12cm]{../../../images/norme_di_progetto/dipendenzaClassi.png}
% 			\captionof{figure}{Diagramma delle classi - Dipendenza}
% 		\end{center}
% 	\item \textbf{Realizzazione}:  indica che una classe implementa un'interfaccia o un contratto definito da un'altra classe. In altre parole, una classe realizza i metodi definiti da un'interfaccia o una classe astratta. Una realizzazione è raffigurata da una linea tratteggiata con una freccia vuota che punta dalla classe che implementa all'interfaccia o classe astratta che viene implementata.
% 	      \begin{center}
% 		      \includegraphics*[width=8cm]{../../../images/norme_di_progetto/realizzazioneClassi.png}
% 		      \captionof{figure}{Diagramma delle classi - Realizzazione}
% 	      \end{center}
% \end{itemize}

\subsubsubsection{Design pattern}
I design pattern  sono soluzioni progettuali generiche e riutilizzabili per problemi comuni che si presentano durante lo sviluppo del software. Sono modelli architetturali, concetti o paradigmi consolidati, spesso espressi attraverso codice o diagrammi, che forniscono una guida per risolvere specifiche problematiche di progettazione software in modo efficiente ed efficace. la documentazione sui design pattern serve come punto di riferimento centrale per tutti gli sviluppatori coinvolti nel progetto, consentendo loro di comprendere rapidamente e facilmente come sono stati implementati determinati pattern nel codice. Questo è particolarmente utile durante le fasi di progettazione, sviluppo e manutenzione del software, in quanto fornisce una chiara visione della struttura architetturale del sistema e dei pattern utilizzati.

\subsubsubsection{Test}
La parte dei test all'interno del processo di sviluppo software è un'attività critica volta a garantire che il prodotto finale soddisfi i requisiti funzionali, prestazionali e di qualità previsti. Questa fase coinvolge diverse attività, che includono la pianificazione dei test, la progettazione dei casi di test, l'esecuzione dei test e l'analisi dei risultati. In questa sezione \hyperref[testing]{\textit{3.2.4}} vengono fornite descrizioni dettagliate delle varie tipologie di test e della terminologia associata.

\subsubsubsection{Metriche}
\begin{table}[!h]
	\centering
	\begin{tabular}{ | c | l | }
		\hline
		\textbf{Codice}                     & \textbf{Nome esteso}       \\
		\hline
		\underline{\hyperlink{14M}{14M-PG}} & Profondità delle Gerarchie \\
		\hline
	\end{tabular}
	\caption{Metriche inerenti la Progettazione}
\end{table}

% \subsubsubsection{Strumenti} Draw.io o altro?

\subsubsection{Codifica}
\subsubsubsection{Descrizione}
La parte di codifica, nota anche come implementazione, rappresenta una fase critica e fondamentale nel processo di sviluppo del software. Durante questa fase, gli sviluppatori assumono il compito di tradurre i requisiti funzionali e non funzionali, delineati durante l' analisi e la progettazione, in codice eseguibile. Questo processo richiede non solo competenze tecniche avanzate, ma anche una solida comprensione degli obiettivi del progetto e delle esigenze degli stakeholder.

\subsubsubsection{Obiettivi}
L'obiettivo principale della codifica è trasformare in modo accurato e efficiente i concetti astratti dei requisiti in istruzioni precise e comprensibili per il computer. Ciò implica la scrittura di codice pulito, ben strutturato e facilmente manutenibile, che sia in grado di soddisfare le esigenze funzionali del software e rispettare gli standard di qualità e le linee guida del progetto.

\subsubsubsection{Norme di codifica}
Le seguenti norme sono state formalizzate in questa maniera:
\begin{itemize}
	\item \textbf{nomi significativi}: i nomi delle variabili, delle costanti, delle classi e dei metodi devono essere significativi e rappresentativi della loro funzione, in modo da facilitare la comprensione del codice;
	\item \textbf{commenti}: il codice deve essere implementato nel modo più leggibile ed autoesplicativo possibile. I commenti verranno impiegati solo ove strettamente necessari;
	\item \textbf{indentazione e formattazione consistente}: il codice deve essere correttamente indentato e formattato, mediante l'uso di tabulazioni, per garantire una corretta leggibilità e comprensione ;
	\item \textbf{gestione delle eccezioni}: il codice deve gestire correttamente le eccezioni e gli errori, fornendo messaggi significativi e gestendo le situazioni anomale in modo appropriato;
	\item \textbf{riuso del codice}: il codice deve essere scritto in modo modulare e riutilizzabile;
	\item \textbf{testabilità}: scrivere funzioni piccole e focalizzate, ad esempio, aiuta a garantire che il codice sia facilmente testabile;
	\item \textbf{sicurezza}: il codice deve essere scritto in modo sicuro, evitando vulnerabilità e falle di sicurezza;
	\item \textbf{performance}: il codice deve essere ottimizzato per garantire prestazioni elevate e tempi di risposta rapidi, con l'uso corretto delle risorse e l'ottimizzazione dei cicli di elaborazione;
	\item \textbf{compatibilità}: il codice deve essere compatibile con le diverse piattaforme, sistemi operativi e browser, per garantire un'esperienza utente uniforme e coerente;
	\item \textbf{conformità ai principi SOLID}: il codice deve rispettare i principi SOLID, che promuovono la scrittura di codice pulito, modulare e manutenibile.
\end{itemize}

\subsubsubsection{Metriche}
\begin{table}[!h]
	\centering
	\begin{tabular}{|c|l|}
		\hline
		\textbf{Codice}                       & \textbf{Nome esteso}       \\
		\hline
		\underline{\hyperlink{15M}{15M-PPM}}  & Parametri per Metodo       \\
		\underline{\hyperlink{16M}{16M-CPC}}  & Campi per classe           \\
		\underline{\hyperlink{17M}{17M-LCPM}} & Linee di codice per metodo \\
		\underline{\hyperlink{18M}{18M-CCM}}  & Complessità Ciclomatica    \\
		\hline
	\end{tabular}
	\caption{Metriche riguardanti l'attività di Codifica}
\end{table}

\subsubsubsection{Strumenti}
\textbf{Visual Studio Code}: è un ambiente di sviluppo integrato (IDE) sviluppato da Microsoft e adottato dal gruppo per lo sviluppo del software. Offre funzionalità avanzate per la scrittura, la modifica e il debug del codice, con supporto per numerosi linguaggi di programmazione e framework.

\newpage
\subsubsection{Configurazione dell'ambiente di esecuzione}
\subsubsubsection{Docker}
L'utilizzo del file Docker garantisce che l'ambiente di sviluppo e produzione sia coerente e riproducibile. Questo approccio non solo assicura che le applicazioni funzionino correttamente in ogni fase del ciclo di vita, ma permette anche una gestione più efficiente delle dipendenze e delle configurazioni.\\
Di seguito un elenco delle best practice per la scrittura di file Docker.
\begin{itemize}
	\item \textbf{Chiarezza e semplicità}: sono principi fondamentali nella scrittura di un Dockerfile. Questi principi aiutano a creare immagini Docker che sono facili da comprendere, mantenere e utilizzare.
	\item \textbf{Versionamento}: è una pratica essenziale per mantenere il controllo sulle diverse versioni del software e delle dipendenze all'interno di un Dockerfile. Questa pratica aiuta a garantire la riproducibilità delle build, a facilitare il debug e a mantenere un ambiente di produzione stabile.
	\item \textbf{Sicurezza}: la sicurezza è una priorità cruciale nella costruzione di immagini Docker. Un Dockerfile sicuro riduce la superficie di attacco, protegge dalle vulnerabilità e garantisce l'integrità dell'applicazione.
	\item \textbf{Efficienza}: nell'ottica di garantire tempi di risposta bassi, mantenendo comunque le pretazioni, i file Docker devono avere un utilizzo corretto delle risorse e una gestione accurata dei container.
	\item \textbf{Gestione delle variabili d'ambiente}: è importante stabilire una pratica rigorosa che renda chiara la configurazione dell'applicazione all'interno del container. Le variabili d'ambiente sono fondamentali per la configurazione dinamica dell'applicazione, consentendo di adattare il comportamento dell'applicazione senza modificare direttamente il codice sorgente.
	\item \textbf{Monitoraggio}: riveste un'importanza fondamentale per garantire una corretta comprensione del comportamento dell'applicazione, individuare eventuali problemi e monitorare le prestazioni in tempo reale. Questo processo permette agli sviluppatori e agli amministratori di sistema di ottenere una visione dettagliata delle attività dell'applicazione, della sua efficienza e di eventuali criticità.
	\item \textbf{Layering}: ogni istruzione nel Dockerfile crea un nuovo layer all'interno dell'immagine Docker. La gestione efficiente di questi strati è cruciale poiché influisce direttamente sulle dimensioni dell'immagine Docker finale e sulla velocità di build.
	\item \textbf{Riduzione delle dimensioni delle immagini}: la riduzione delle dimensioni delle immagini Docker è un aspetto fondamentale per migliorare l'efficienza di deployment, ridurre i tempi di trasferimento e ottimizzare l'utilizzo delle risorse del sistema.
	\item \textbf{Documentazione}: fornire una documentazione esaustiva e chiara con un Dockerfile è essenziale per garantire la comprensione del suo funzionamento, facilitare la manutenzione e favorire la collaborazione tra i membri del team.
	\item \textbf{Testing}: testare un Dockerfile in modo completo è cruciale per garantire che l'immagine Docker risultante sia configurata correttamente e funzioni come previsto.
\end{itemize}

\subsubsubsection{Strumenti}
\begin{itemize}
	\item \textbf{Docker}: è una piattaforma open-source che permette di creare, distribuire e gestire applicazioni in ambienti di sviluppo e produzione utilizzando container leggeri e autonomi;
	\item \textbf{Visual Studio Code}: è un ambiente di sviluppo integrato (IDE) sviluppato da Microsoft e adottato dal gruppo per lo sviluppo del software. Offre funzionalità avanzate per la scrittura, la modifica e il debug del codice, con supporto per numerosi linguaggi di programmazione e framework.
\end{itemize}
