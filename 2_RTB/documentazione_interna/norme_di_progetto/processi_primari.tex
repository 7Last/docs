\section{Processi primari}
\subsection{Fornitura}
\subsubsection{Introduzione}
Il processo di fornitura è un percorso strutturato che stabilisce un accordo contrattuale tra il fornitore e il cliente e guida lo sviluppo e la consegna di un prodotto software, dalla concezione iniziale fino alla manutenzione post-rilascio. Questo processo è fondamentale per garantire che il software soddisfi i requisiti del cliente, sia di alta qualità e venga consegnato nei tempi e nei costi previsti.
\subsubsection{Attività}
Il processo di fornitura comprende le seguenti fasi:
\begin{itemize}
	\item \textbf{preparazione della proposta}: questa fase iniziale prevede la raccolta di informazioni e la stesura di una proposta formale per il cliente. Si suddivide in:
		\begin{itemize}
			\item analisi delle esigenze del cliente;
			\item studio di fattibilità;
			\item elaborazione della proposta;
		\end{itemize}
	\item \textbf{contrattazione}: durante questa fase il fornitore e il cliente discutono e negoziano i termini del contratto. Alcune attività tipiche di questa fase includono:
		\begin{itemize}
			\item discussione dei termini e delle condizioni;
			\item stesura e revisione del contratto;
			\item firma del contratto;
		\end{itemize}
	\item \textbf{pianificazione}: fondamentale per organizzare e programmare le attività del progetto. Questa fase include:
		\begin{itemize}
			\item stesura delle milestones;
			\item stesura del piano di progetto;
			\item assegnazione dei compiti e delle risorse;
		\end{itemize}
	\item \textbf{esecuzione}: si effettua la realizzazione concreta del progetto, con la costruzione del prodotto software. L'attività è costituita principalmente da:
		\begin{itemize}
			\item sviluppo del software;
			\item test e verifica;
			\item documentazione;
		\end{itemize}
	\item \textbf{revisione}: prevede una valutazione approfondita del lavoro svolto per garantire che tutto sia conforme agli standard di qualità e ai requisiti contrattuali. Questa fase include:
		\begin{itemize}
			\item revisione del codice;
			\item test di accettazione;
			\item correzione delle discrepanze;
		\end{itemize}
	\item \textbf{consegna}: consiste nella consegna del prodotto finale al cliente e nella preparazione per il supporto post-rilascio Si compone di:
		\begin{itemize}
			\item consegna del software;
			\item formazione del personale;
			\item supporto post-rilascio;
		\end{itemize}
\end{itemize}

\subsubsection{Comunicazioni con l'azienda proponente}
\textit{SyncLab S.r.l.} offre un indirizzo email e un canale Discord per la comunicazione tramite messaggi, oltre a Google Meet per gli incontri telematici. Gli incontri online si terranno inizialmente con cadenza bisettimanale, con la possibilità di organizzare incontri extra su richiesta del gruppo. Per ogni colloquio con l’azienda proponente sarà redatto un verbale che riassumerà i temi trattati. Tali documenti saranno disponibili nella \href{https://github.com/7Last/docs}{\underline{repository}} del team \textit{7Last}.
\newpage
\subsubsection{Documentazione fornita}
Di seguito saranno elencati i documenti che il gruppo \textit{7last} consegnerà all'azienda \textit{SyncLab S.r.l.} e ai committenti \textit{Prof. Tullio Vardanega} e \textit{Prof. Riccardo Cardin}.

\subsubsubsection{Piano di qualifica}
Il \textit{Piano di Qualifica} è un documento che specifica le responsabilità e le attività del verificatore nel progetto, delineando le strategie e gli approcci adottati per garantire la qualità del prodotto software in fase di sviluppo. Redatto dall’amministratore, questo documento descrive le modalità di verifica e validazione, nonché gli standard e le procedure di qualità da seguire durante l'intero ciclo di vita del progetto. Tutti i membri del team di progetto si riferiranno a questo documento per assicurarsi di raggiungere la qualità desiderata. Questo documento è organizzato in diverse sezioni, tra cui:
\begin{itemize}
	\item \textbf{qualità di processo}: definisce gli standard e le procedure adottate durante il progetto al fine di garantire che i processi seguiti siano di alta qualità;
	\item \textbf{qualità di prodotto}: stabilisce i criteri, le metriche e gli standard da rispettare affinchè il prodotto finale sia di alta qualità;
	\item \textbf{specifica dei test}: contiene la descrizione di tutti i test necessari a verificare che il prodotto soddisfi i requisiti specificati;
	\item \textbf{cruscotto per il miglioramento}: riporta le attività di verifica svolte e le problematiche riscontrate durante lo sviluppo del software, con l'obiettivo di identificare aree di miglioramento.
\end{itemize}

%mettiamo valutazione dei capitolati?

% \subsubsubsection{Valutazione dei capitolati} 
% Il presente documento offre una valutazione approfondita dei capitolati d'appalto presentati in data 2023-10-17. Per ciascun progetto, vengono esaminate le richieste del proponente, le possibili soluzioni e le eventuali criticità.
% La valutazione si articola nelle seguenti sezioni:
% \begin{itemize}
% 	\item \textbf{descrizione}: viene elencato il nome del progetto, l'azienda proponente, i committenti e l'obiettivo del progetto;
% 	\item \textbf{dominio applicativo}: viene descritto il contesto del progetto;
% 	\item \textbf{dominio tecnologico}: vengono descritte le tecnologie utilizzate per lo sviluppo del progetto;
% 	\item \textbf{aspetti positivi};
% 	\item \textbf{aspetti negativi}.
% \end{itemize}

\subsubsubsection{Analisi dei requisiti}
L'\textit{Analisi dei Requisiti} non solo aiuta a definire e comprendere le esigenze e le aspettative degli stakeholder in relazione al prodotto software in fase di sviluppo, ma rappresenta anche un punto di riferimento fondamentale che permea l'intero ciclo di vita del progetto. Questo documento fornisce una panoramica chiara delle richieste degli utenti finali e degli altri soggetti coinvolti nel progetto. Serve come guida per il team di sviluppo, fornendo una mappa dettagliata delle funzionalità da implementare e dei requisiti da soddisfare. Infine, durante le fasi di verifica e validazione, questo documento viene utilizzato come base di riferimento per garantire che il prodotto software sviluppato rispetti le richieste e le necessità degli utenti finali, contribuendo così al successo complessivo del progetto.
Il documento è composto principalmente da:
\begin{itemize}
	\item \textbf{descrizione}: fornisce una panoramica generale del progetto, del contesto in cui il software verrà utilizzato e degli obiettivi principali. Include una spiegazione chiara dello scopo del documento e delle sue finalità, fornendo un quadro complessivo del progetto e del suo contesto;
	\item \textbf{elenco dei casi d'uso}: qui vengono riportati tutti gli scenari possibili in cui il sistema software potrebbe essere utilizzato dagli utenti finali. Ogni caso d'uso descrive dettagliatamente le azioni che gli utenti compiono nel sistema, permettendo di identificare requisiti non ovvi inizialmente. Questa sezione fornisce una visione dettagliata delle interazioni previste tra gli utenti e il sistema, contribuendo a definire le funzionalità e le caratteristiche del software;
	\item \textbf{elenco dei requisiti}: in questa sezione vengono specificati tutti i vincoli richiesti dal proponente o dedotti in base all'analisi dei casi d'uso associati ad essi. I requisiti delineano le funzionalità, le prestazioni, le restrizioni e altri aspetti critici del software che devono essere soddisfatti. Essi rappresentano le basi su cui il team progetta e implementa il software, assicurando che il prodotto finale rispetti le aspettative degli stakeholder e soddisfi le necessità degli utenti finali.
\end{itemize}

\subsubsubsection{Piano di progetto}
Il \textit{Piano di Progetto} delinea in modo dettagliato e organizzato tutti gli aspetti e le attività coinvolte nella gestione di un progetto di sviluppo del software. Esso funge da strumento di pianificazione, monitoraggio e controllo, offrendo una roadmap chiara e ben definita per il team di progetto\\
Comprende le seguenti informazioni:
\begin{itemize}
	\item \textbf{analisi dei rischi}: identificazione delle potenziali sfide che potrebbero insorgere durante il processo e che potrebbero arrecare ritardi e/o impedimenti al progredire del progetto. Il gruppo si impegna a fornire soluzioni per tali problemi il prima possibile. I rischi sono classificati in tre categorie principali: rischi organizzativi, rischi tecnologici e rischi comunicativi;
	\item \textbf{modello di sviluppo}: illustra l'approccio organizzato e metodologico implementato dal team per sviluppare il prodotto;
	\item \textbf{pianificazione temporale}: definisce i periodi temporali con eventi e attività correlate, all'interno di un calendario. Per ciascun periodo, saranno specificati i compiti dei vari ruoli e una stima del tempo richiesto da ciascun membro del team per completare le rispettive attività;
	\item \textbf{preventivo}: valuta la durata prevista di ciascun periodo, indicando il tempo necessario per poter portare a termine tutte le attività pianificate;
	\item \textbf{revisione dell'avanzamento}: analizza il lavoro effettivamente svolto rispetto alle previsioni, al fine di ottenere uno stato di avanzamento del progetto al termine di ogni periodo.
\end{itemize}

\subsubsubsection{Glossario}
Il \textit{Glossario} è un elenco dettagliato e organizzato di termini, acronimi e definizioni utilizzati nel contesto del progetto. Fornisce una chiara comprensione dei concetti e dei termini specifici impiegati nel progetto, garantendo una comunicazione efficace e coesa tra tutti i membri del team, nonché con gli stakeholder esterni.

\subsubsubsection{Lettera di presentazione}
La \textit{Lettera di Presentazione} costituisce il mezzo attraverso il quale il gruppo \textit{7Last} espone il proprio interesse a partecipare attivamente alla fase di revisione del prodotto software. Questo documento non solo mette in luce la disponibilità della documentazione rilevante per i committenti e il proponente, ma stabilisce anche i termini concordati per la consegna del prodotto finito.

\subsubsection{Strumenti}
Di seguito sono descritti gli strumenti software impiegati nel processo di fornitura:
\begin{itemize}
	\item \textbf{Discord}: come piattaforma per le riunioni interne e come un metodo informale per contattare l'azienda proponente tramite messaggistica;
	\item \textbf{Google Meet}: utilizzato per le riunioni con la proponente;
	\item \textbf{LaTeX}: un sistema di preparazione di documenti utilizzato principalmente per la creazione di documenti tecnici e scientifici;
	% \item \textbf{Git}: un sistema di controllo di versione distribuito utilizzato per il tracciamento delle modifiche ai documenti e per la collaborazione tra i membri del gruppo;
	\item \textbf{GitHub}: un servizio di hosting per progetti software che offre funzionalità di controllo di versione e collaborazione;
\end{itemize}

\subsection{Sviluppo}
\subsubsection{Introduzione}
L'ISO/IEC 12207:1995 fornisce un quadro completo e strutturato per la gestione del ciclo di vita del software. Questo standard definisce i processi, le attività e le mansioni coinvolte nello sviluppo, nell'acquisizione e nella manutenzione del software.
È fondamentale completare tali operazioni in stretto rispetto alle direttive e ai requisiti definiti nel contratto con il cliente, assicurando quindi una realizzazione precisa e in linea con le specifiche richieste.
\subsubsection{Analisi dei requisiti}
\subsubsubsection{Descrizione}
L' \textit{analisi dei requisiti} ha lo scopo di identificare, definire e documentare in modo esaustivo le necessità, le funzionalità e le prestazioni che il sistema software deve soddisfare. Questo documento rappresenta il punto di partenza cruciale per il processo di sviluppo del software, fornendo una base solida e chiara per la progettazione, l'implementazione e la verifica del sistema. Attraverso l'analisi dei requisiti, si cerca di comprendere appieno le esigenze degli stakeholder, inclusi utenti finali, clienti e altri soggetti coinvolti nel progetto, al fine di garantire che il prodotto software sviluppato soddisfi le loro aspettative e necessità. L'analisi dei requisiti include tipicamente la raccolta e la documentazione dei requisiti funzionali e non funzionali, la definizione dei casi d'uso, la modellazione dei dati e dei processi di business, nonché la prioritizzazione e la tracciabilità dei requisiti lungo l'intero ciclo di vita del software. Inoltre, questo documento fornisce un punto di riferimento essenziale per tutti i membri del team di sviluppo, consentendo loro di concentrarsi sulle esigenze del cliente e di mantenere l'allineamento con gli obiettivi e le aspettative del progetto.
Questa attività richiede di rispondere a domande fondamentali come "Quali sono i vincoli tecnici, legali o di altro tipo?", "Quali sono i casi d'uso e gli scenari di utilizzo del sistema?".
\newpage
\subsubsubsection{Scopo}
\begin{itemize}
	\item Definire gli obiettivi del prodotto al fine di soddisfare le aspettative;
	\item promuovere una comprensione condivisa tra tutte le parti interessate;
	\item consentire una stima accurata delle tempistiche e dei costi del progetto;
	\item fornire ai progettisti requisiti chiari e facilmente comprensibili;
	\item agevolare l'attività di verifica e di test fornendo indicazioni pratiche di riferimento.
\end{itemize}
\subsubsubsection{Documentazione}
Agli analisti il compito di redigere l'\textit{analisi dei requisiti}, comprendendo i seguenti elementi:
\begin{itemize}
	\item \textbf{introduzione}: presentazione e scopo del documento stesso;
	\item \textbf{descrizione}:  analisi approfondita del prodotto, includendo:
	      \begin{itemize}
		      \item obiettivi del prodotto;
		      \item funzionalità del prodotto;
		      \item caratteristiche utente;
		      \item tecnologie impiegate;
	      \end{itemize}
	\item \textbf{casi d'uso}: descrizione delle funzionalità offerte dal sistema dal punto di vista dell'utente, includendo:
	      \begin{itemize}
		      \item utenti esterni al sistema;
		      \item elenco dei casi d'uso, comprensivo di:
		            \begin{itemize}
			            \item descrizioni dei casi d'uso in formato testuale;
			            \item diagrammi dei casi d'uso;
		            \end{itemize}
		      \item eventuali diagrammi di attività per facilitare la comprensione dei processi relativi alle funzionalità;
	      \end{itemize}
	\item \textbf{requisiti}:
	      \begin{itemize}
		      \item requisiti funzionali;
		      \item requisiti qualitativi;
		      \item requisiti di vincolo.
	      \end{itemize}
\end{itemize}

\subsubsubsection{Casi d'uso}
I casi d'uso forniscono una dettagliata descrizione delle funzionalità del sistema dal punto di vista degli utenti, delineando come il sistema risponde a specifiche azioni o scenari.
Essenzialmente, i casi d'uso sono strumenti utilizzati nell'analisi dei requisiti per catturare e illustrare chiaramente e comprensibilmente come gli utenti interagiranno con il software e quali saranno i risultati di tali interazioni. \\
\\
Ogni caso d'uso testuale deve includere:
\begin{enumerate}
	\item \textbf{Identificativo}:
	      \begin{center}
		      \textbf{UC-[identificativo\_caso\_principale].[identificativo\_sotto\_caso]}
	      \end{center}
	      \begin{itemize}
		      \item \textbf{Identificativo sotto caso}: identificativo numerico del sotto caso d'uso (presente solo se si tratta di un sotto caso d'uso);
		      \item \textbf{titolo}: breve e chiaro titolo del caso d'uso.
	      \end{itemize}
	\item \textbf{Attore principale}: entità esterna che interagisce attivamente con il sistema per soddisfare una propria necessità.
	\item \textbf{Scenario principale}: una sequenza di eventi che si verificano quando un attore interagisce con il sistema per raggiungere l'obiettivo del caso d'uso (postcondizioni).
	\item \textbf{Precondizioni}: lo stato in cui deve trovarsi il sistema affinché la funzionalità sia disponibile per l'attore.
	\item \textbf{Postcondizioni}: lo stato in cui si trova il sistema dopo l'esecuzione dello scenario principale.
	\item \textbf{User story}: una breve descrizione di una funzionalità del software, scritta dal punto di vista dell'utente, che fornisce contesto, obiettivi e valore.
	      \begin{itemize}
		      \item L'user story viene scritta nella forma: "Come [utente] desidero poter [funzionalità] per [valore aggiunto]".
	      \end{itemize}
\end{enumerate}

\subsubsubsection{Diagrammi dei casi d'uso}
offrono una rappresentazione visiva delle interazioni tra gli utenti finali (o attori) e il sistema software, delineando i vari scenari in cui il sistema verrà utilizzato. Ogni caso d'uso descrive una sequenza specifica di azioni che gli attori compiono per raggiungere un obiettivo particolare con il sistema. I diagrammi dei casi d'uso aiutano a identificare i requisiti funzionali del sistema, fornendo una comprensione chiara e condivisa delle aspettative degli utenti. Inoltre, facilitano la comunicazione tra gli sviluppatori e gli stakeholder, assicurando che tutte le funzionalità necessarie siano considerate e correttamente implementate nel software.
Di seguito vengono elencati i principali componenti di un diagramma dei casi d'uso:
\begin{itemize}
	\item \textbf{Attori}: rappresentano gli utenti o i sistemi esterni che interagiscono con il sistema software. Gli attori possono essere persone, altri sistemi software o dispositivi che utilizzano le funzionalità del sistema. Sono rappresentati come figure stilizzate. 
		\begin{center}
			\includegraphics*[width=4cm]{../../../images/norme_di_progetto/attore.png}
			\captionof{figure}{Diagramma dei casi d'uso - Attore}
		\end{center} 
	\newpage
	\item \textbf{Casi d'uso}: rappresentano le funzionalità o i servizi offerti dal sistema che producono un risultato di valore per un attore. Ogni caso d'uso descrive una sequenza specifica di interazioni tra gli attori e il sistema. Sono rappresentati come ovali.
		\begin{center}
			\includegraphics*[width=10cm]{../../../images/norme_di_progetto/casoDiUso.png}
			\captionof{figure}{Diagramma dei casi d'uso - Caso d'uso}
		\end{center}
	\newpage
	\item \textbf{Sottocasi d'uso}: rappresentano scenari specifici e dettagliati che si verificano all'interno di un caso d'uso principale. Questi aiutano a modularizzare e riutilizzare le funzionalità comuni e a gestire le variazioni nei processi.
		\begin{center}
			\includegraphics*[width=17cm]{../../../images/norme_di_progetto/sottocasiDiUso.png}
			\captionof{figure}{Diagramma dei casi d'uso - Sottocaso d'uso}
		\end{center}
	\newpage
	
	\item \textbf{Relazioni tra Attori e Casi d'Uso}
	    \begin{itemize}
			\item \textbf{Associazione}: è la relazione fondamentale che collega un attore a un caso d'uso, indicando che l'attore interagisce con il sistema per eseguire quella specifica funzione. Viene rappresentata da una linea semplice che collega l'attore al caso d'uso.

				\begin{center}
					\includegraphics*[width=15cm]{../../../images/norme_di_progetto/associazione.png}
					\captionof{figure}{Diagramma dei casi d'uso - Associazione}
				\end{center}
	    \end{itemize} 

	\item \textbf{Relazioni tra Attori}
		\begin{itemize}
			\item \textbf{Generalizzazione}: rappresenta una relazione ereditaria in cui un attore figlio eredita il comportamento di un attore genitore. Questo viene utilizzato quando diversi attori condividono comportamenti comuni. Viene rappresentata da una freccia con una linea piena che punta dall'attore figlio all'attore genitore.
				\begin{center}
					\includegraphics*[width=2cm]{../../../images/norme_di_progetto/generalizzazioneTraAttori.png}
					\captionof{figure}{Diagramma dei casi d'uso - Generalizzazione tra attori}
				\end{center}
		\end{itemize}
	\newpage
	
	\item \textbf{Relazioni tra Casi d'Uso}
	    \begin{itemize}
		    \item \textbf{Inclusione}: rappresenta una relazione in cui un caso d'uso (incluso) è utilizzato come parte di un altro caso d'uso (principale). Il caso d'uso incluso contiene funzionalità che sono riutilizzate in più casi d'uso principali, permettendo di evitare la duplicazione di comportamenti comuni. È rappresentata da una freccia tratteggiata con l'etichetta <<include>> che parte dal caso d'uso principale e punta verso il caso d'uso incluso.
				\begin{center}
					\includegraphics*[width=15cm]{../../../images/norme_di_progetto/inclusione.png}
					\captionof{figure}{Diagramma dei casi d'uso - Inclusione}
				\end{center} 
		\newpage
		    \item \textbf{Estensione}: mostra una relazione in cui un caso d'uso (esteso) aggiunge comportamento opzionale o condizionale a un altro caso d'uso (principale). Il caso d'uso esteso viene eseguito solo sotto determinate condizioni o su richiesta. L'estensione è rappresentata da una freccia tratteggiata con l'etichetta <<extend>> che parte dal caso d'uso esteso e punta verso il caso d'uso principale.
				\begin{center}
					\includegraphics*[width=15cm]{../../../images/norme_di_progetto/estensione.png}
					\captionof{figure}{Diagramma dei casi d'uso - Estensione}
				\end{center} 
		\newpage
		    \item \textbf{Generalizzazione casi d'uso}: rappresenta una relazione ereditaria in cui un caso d'uso figlio eredita il comportamento di un caso d'uso genitore. Questo è utile per descrivere variazioni o estensioni di un comportamento base. È rappresentata da una freccia con una linea piena che punta dal caso d'uso figlio al caso d'uso genitore.
				\begin{center}
					\includegraphics*[width=15cm]{../../../images/norme_di_progetto/generalizzazioneCasiDiUso.png}
					\captionof{figure}{Diagramma dei casi d'uso - Generalizzazione tra casi d'uso}
				\end{center}
	    \end{itemize}
	\item \textbf{Sistema}: delimita i confini del sistema software, indicando quali funzionalità sono incluse e quali sono esterne al sistema. Il sistema è rappresentato come un rettangolo che racchiude i casi d'uso.
		\begin{center}
			\includegraphics*[width=8cm]{../../../images/norme_di_progetto/sistema.png}
			\captionof{figure}{Diagramma dei casi d'uso - Sistema}
		\end{center}
\end{itemize}

\newpage
\subsubsubsection{Requisiti}
Delineano una descrizione dettagliata delle funzionalità e delle caratteristiche che il software deve possedere per soddisfare le esigenze degli utenti e degli stakeholder. Questi requisiti costituiscono la base per tutto il ciclo di sviluppo del software e sono fondamentali per il successo del progetto. Si suddividono generalmente in due categorie principali: 
\begin{itemize}
	\item \textbf{requisiti funzionali}, i quali descrivono le azioni specifiche che il sistema deve essere in grado di eseguire. Rispondono alla domanda "cosa deve fare il sistema?";
	\item \textbf{requisiti non funzionali}, che definiscono le proprietà e le caratteristiche del sistema che ne influenzano il funzionamento e l'uso. Rispondono alla domanda "come deve comportarsi il sistema?".
\end{itemize}
Una definizione precisa dei requisiti è essenziale: devono essere chiari e rispondere completamente alle aspettative del cliente o del proponente.\\
Ogni requisito è costituito da:
\begin{enumerate}
	\item \textbf{codice}: i requisiti sono codificati nel seguente modo:
	      \begin{center}
		      \textbf{R[Tipologia]-[Codice]}
	      \end{center}
	      dove
	      \begin{itemize}
			\item \textbf{[Tipologia]}: indica la tipologia del requisito, che può essere:
			\begin{itemize}
				\item \textbf{F}: requisito funzionale;
				\item \textbf{Q}: requisito di qualità;
				\item \textbf{V}: requisito di vincolo.
			\end{itemize}
			\item \textbf{[Codice]}: è un numero progressivo che identifica univocamente il requisito.
	      \end{itemize}
	\item \textbf{Importanza}: indica il grado di importanza del requisito, che può essere:
	      \begin{itemize}
		      \item \textbf{Obbligatorio}: irrinunciabile per il \href{https://7last.github.io/docs/rtb/documentazione-interna/glossario\#committente}{committente\textsubscript{G}};
		      \item \textbf{Desiderabile}: non strettamente necessario, ma che porta valore aggiunto al prodotto;
		      \item \textbf{Opzionale}: relativo a funzionalità aggiuntive.
	      \end{itemize}
	\item \textbf{Fonte}: indica la fonte da cui è stato identificato il requisito, che può essere:
	      \begin{itemize}
		      \item \href{https://7last.github.io/docs/rtb/documentazione-interna/glossario\#capitolato}{\textbf{capitolato}\textsubscript{G}}: requisiti individuati a seguito dell'analisi dello stesso;
		      \item \textbf{interno}: requisiti individuati durante le riunioni interne e da coloro che hanno il ruolo di analista;
		      \item \textbf{esterno}: requisiti aggiuntivi individuati in seguito a incontri con la \href{https://7last.github.io/docs/rtb/documentazione-interna/glossario\#proponente}{proponente\textsubscript{G}};
		      \item \href{https://7last.github.io/docs/rtb/documentazione-interna/glossario\#piano-di-qualifica}{\textbf{piano di qualifica}\textsubscript{G}}: requisiti necessari per adeguare il prodotto agli standard di qualità definiti nel documento \href{https://7last.github.io/docs/rtb/documentazione-interna/glossario\#piano-di-qualifica}{\textit{Piano di Qualifica}\textsubscript{G}};
		      \item \href{https://7last.github.io/docs/rtb/documentazione-interna/glossario\#norme-di-progetto}{\textbf{norme di progetto}\textsubscript{G}}: requisiti necessari per adeguare il prodotto alle norme stabilite nel documento \href{https://7last.github.io/docs/rtb/documentazione-interna/glossario\#norme-di-progetto}{\textit{Norme di Progetto}\textsubscript{G}}.
	      \end{itemize}
\end{enumerate}


\subsubsubsection{Metriche}
Nell'analisi dei requisiti, le metriche sono strumenti utilizzati per misurare vari aspetti del processo di sviluppo e del prodotto finale. All'interno di un'analisi dei requisiti, le metriche svolgono un ruolo cruciale nel garantire che il software sia sviluppato in modo efficiente, soddisfi gli standard di qualità attesi e adempia alle specifiche richieste dagli stakeholder.\\
\begin{table}[!h] %? Il riferimento da mettere direttamente sulla colonna "Metrica"?
	\centering
	\begin{tabular}{|c|c|c|}
		\hline
		\textbf{Metrica}                    & \textbf{Nome completo}\\
		\hline
		\hyperlink{subsection.6.2}{0M-CRO}  & Copertura dei Requisiti Obbligatori. \\
		\hyperlink{subsection.6.2}{1M-CRD}  & Copertura dei Requisiti Desiderabili. \\
		\hyperlink{subsection.6.2}{2M-CROP} & Copertura dei Requisiti Opzionali. \\
		\hline
	\end{tabular}
	\caption{Metriche per l'analisi dei requisiti}
	\label{tab:1}
\end{table}

\subsubsubsection{Strumenti}
\textbf{StarUML} è uno strumento versatile e potente per la modellazione software, essenziale per chiunque desideri adottare un approccio strutturato e visivo alla progettazione e sviluppo di sistemi software complessi. Con il suo supporto per UML e altre notazioni di modellazione, le capacità di estensibilità e collaborazione, e la generazione automatica di documentazione, StarUML rappresenta una risorsa preziosa per migliorare la qualità e l'efficienza dei progetti software.\\

\subsubsection{Progettazione}
\subsubsubsection{Descrizione}
L'attività di progettazione svolge un ruolo fondamentale nello sviluppo del software, consentendo di definire l'architettura, i componenti e le interfacce del sistema in modo da soddisfare i requisiti definiti durante l'analisi.  Questa fase si basa sull'analisi dei requisiti e ha lo scopo di tradurre i requisiti funzionali e non funzionali in una soluzione tecnica implementabile. 

\subsubsubsection{Obiettivi}
L'obiettivo principale è garantire che i requisiti siano soddisfatti attraverso un sistema di qualità definito dall'architettura del prodotto. Ciò comporta:
\begin{itemize}
	\item \textbf{definizione dell'architettura}: in questa fase si definisce l'architettura del sistema, determinando la struttura generale, i componenti principali e le relazioni tra di essi. Questo include la scelta delle tecnologie, dei linguaggi di programmazione e delle piattaforme da utilizzare;
	\item \textbf{suddivisione in moduli}: si suddivide il sistema in moduli o componenti più piccoli e gestibili, ciascuno con responsabilità specifiche. Questa suddivisione facilita lo sviluppo, il testing e la manutenzione del software;
	\item \textbf{definizione delle interfacce}: si specificano le interfacce tra i diversi moduli o componenti del sistema, stabilendo come essi comunicano e interagiscono tra di loro. Questo garantisce una corretta integrazione e interoperabilità del sistema;
	\item \textbf{identificazione delle risorse}: vengono identificate le risorse necessarie per implementare il sistema, come hardware, software, risorse umane e finanziarie. Questo aiuta a pianificare e gestire le risorse in modo efficace durante lo sviluppo;
	\item \textbf{valutazione delle prestazioni}: si valutano le prestazioni del sistema, identificando potenziali problemi di scalabilità, affidabilità e prestazioni. Questo consente di ottimizzare il design per garantire che il sistema soddisfi i requisiti di prestazione.
\end{itemize}
\newpage
\subsubsubsection{Documentazione}
\textbf{Specifica tecnica}\\ Fornisce una guida dettagliata ed esaustiva per la progettazione e lo sviluppo del sistema. In essa sono delineate con precisione l'architettura tecnica del software, con tutti i suoi componenti e interfacce, le funzionalità che il sistema dovrà offrire e le tecnologie che saranno impiegate per realizzarlo. Questo documento costituisce il punto di partenza per l'intero ciclo di sviluppo del software, fornendo una base solida e strutturata su cui il team di sviluppo potrà lavorare in modo efficace ed efficiente. Tra gli elementi chiave inclusi in questo documento vi sono:
\begin{itemize}
	\item \textbf{architettura del sistema}: questa sezione delinea l'architettura generale del sistema software, identificando i principali componenti, i moduli e le interfacce. Include anche informazioni sull'organizzazione logica e fisica del sistema, come ad esempio la suddivisione in livelli o strati e le relazioni tra di essi;
	\item \textbf{tecnologie utilizzate}: specifica le tecnologie, i linguaggi di programmazione, i framework e le librerie che saranno impiegate nello sviluppo del sistema. Questo include anche eventuali tool e ambienti di sviluppo adottati;
	\item \textbf{struttura dei dati}: descrive la struttura e la gestione dei dati all'interno del sistema, inclusi database, file system, protocolli di accesso ai dati e modelli di persistenza;
	\item \textbf{interfacce esterne}: indica le interfacce con altri sistemi o applicazioni esterne con cui il sistema deve interagire. Questo include anche la definizione dei formati dei dati scambiati e i protocolli di comunicazione utilizzati;
	\item \textbf{design pattern}: descrizione dei design pattern utilizzati per risolvere problemi comuni e ricorrenti durante lo sviluppo del software;
	\item \textbf{pianificazione e risorse}: fornisce una pianificazione dettagliata del lavoro da svolgere per implementare la specifica tecnica, inclusi tempi, costi e risorse necessarie;
	\item \textbf{procedure di testing e validazione}: indicazioni sulle procedure e gli strumenti da utilizzare per verificare e validare il prodotto, garantendo che soddisfi i requisiti e le aspettative del cliente;
	\item \textbf{requisiti tecnici}: elenco dettagliato dei requisiti tecnici che il prodotto deve soddisfare, con indicazioni sulle funzionalità, le prestazioni e le caratteristiche richieste;
	\item \textbf{sicurezza e privacy}: specifica i requisiti e le misure di sicurezza che saranno implementati nel sistema per proteggere i dati sensibili e garantire la privacy degli utenti.
\end{itemize}

\subsubsubsection{Qualità dell'architettura}
\begin{itemize}
	\item \textbf{Scalabilità}: rappresenta la capacità del sistema di gestire un aumento del carico di lavoro o delle risorse senza compromettere le prestazioni o la qualità del servizio. Un'architettura scalabile può adattarsi dinamicamente alle variazioni delle richieste degli utenti e delle risorse disponibili;
	\item \textbf{flessibilità}: capacità del sistema di adattarsi ai cambiamenti nei requisiti o nell'ambiente operativo senza richiedere modifiche significative. Un'architettura flessibile è caratterizzata da componenti ben separati e interfacce standardizzate, che consentono una facile modifica e l'aggiunta di nuove funzionalità;
	\item \textbf{sicurezza}: protezione dei dati, delle risorse e del sistema da minacce esterne e interne. Un'architettura sicura include meccanismi di autenticazione, autorizzazione, crittografia e controllo degli accessi per garantire la riservatezza, l'integrità e la disponibilità delle informazioni;
	\item \textbf{manutenibilità}: ovvero la facilità di comprendere, modificare e correggere il software nel corso del suo ciclo di vita. Un'architettura manutenibile è caratterizzata da un codice ben strutturato, documentato e modularizzato, che consente agli sviluppatori di individuare e risolvere rapidamente eventuali problemi;
	\item \textbf{testabilità}: facilità di testare il software per garantire che soddisfi i requisiti funzionali e non funzionali. Un'architettura testabile include componenti ben isolati e interfacce chiare che consentono l'automazione dei test e la verifica continua della qualità del software;
	\item \textbf{affidabilità}: garanzia del corretto funzionamento del sistema in condizioni normali e anomale. Un'architettura affidabile include meccanismi di gestione degli errori, di recupero e di ripristino che consentono al sistema di continuare a operare in modo affidabile anche in presenza di guasti o interruzioni;
	\item \textbf{performance}: capacità del sistema di fornire risposte rapide e tempi di elaborazione efficienti anche in presenza di carichi di lavoro elevati. Un'architettura performante include ottimizzazioni del codice, della gestione delle risorse e dell'accesso ai dati per massimizzare le prestazioni del sistema;
	\item \textbf{usabilità}: facilità di utilizzo e comprensione del sistema da parte degli utenti finali. Un'architettura usabile include un'interfaccia utente intuitiva, una struttura di navigazione chiara e una presentazione coerente delle informazioni per garantire un'esperienza utente positiva;
	\item \textbf{compatibilità}: capacità del sistema di interoperare con altri sistemi, piattaforme o tecnologie senza problemi. Un'architettura compatibile include standard aperti, interfacce ben definite e protocolli di comunicazione standardizzati che consentono l'integrazione con sistemi esterni;
	\item \textbf{documentazione}: fornitura di documentazione completa e accurata sull'architettura del sistema, inclusi diagrammi, specifiche tecniche, manuale utente e guide per gli sviluppatori. Una buona documentazione facilita la comprensione, la manutenzione e l'evoluzione del sistema nel tempo;
	\item \textbf{safety}: l'architettura deve garantire la sicurezza del sistema, in modo che possa proteggere i dati e le informazioni sensibili in seguito a malfunzionamenti.
\end{itemize}

\subsubsubsection{Diagrammi UML}
Vantaggi:
\begin{itemize}
	\item \textbf{chiarezza visiva}: forniscono una rappresentazione visuale chiara e intuitiva delle relazioni e delle interazioni tra gli elementi del sistema software, facilitando la comprensione del sistema da parte degli stakeholder;
	\item \textbf{standardizzazione}: UML è uno standard riconosciuto a livello internazionale per la modellazione dei sistemi software, il che significa che i diagrammi UML sono facilmente comprensibili da parte di professionisti del settore in tutto il mondo;
	\item \textbf{comunicazione efficace}: forniscono un linguaggio comune per la comunicazione tra gli sviluppatori, gli stakeholder tecnici e non tecnici e altri membri del team, consentendo una comunicazione più efficace e una condivisione delle informazioni più chiara;
	\item \textbf{analisi e progettazione}: possono essere utilizzati durante le fasi di analisi e progettazione del ciclo di sviluppo del software per visualizzare e analizzare i requisiti, le relazioni tra i componenti e le interazioni del sistema;
	\item \textbf{modellazione e requisiti}: UML consente di modellare i requisiti del sistema in modo chiaro e strutturato, identificando casi d'uso, scenari e vincoli che guidano lo sviluppo del software;
	\item \textbf{facilità di manutenzione}: è più facile comprendere l'architettura del sistema e individuare eventuali problemi o aree di miglioramento, facilitando così la manutenzione e l'evoluzione del software nel tempo;
	\item \textbf{supporto agli standard di progettazione}: I diagrammi UML possono essere utilizzati per applicare e comunicare i principi di progettazione software ben consolidati, come l'incapsulamento, l'ereditarietà e il polimorfismo;
	\item \textbf{documentazione}: possono essere utilizzati per generare documentazione tecnica dettagliata sul sistema software, fornendo una guida completa per gli sviluppatori, gli utenti finali e gli altri stakeholder.
\end{itemize}
\newpage
\begin{flushleft}
A supporto della progettazione, il team utilizzerà i seguenti \textbf{diagrammi delle classi}.
\end{flushleft}
Ogni diagramma delle classi rappresenta le proprietà e le relazioni tra le varie componenti di un sistema, offrendo una visione chiara e dettagliata della struttura del sistema.\\
Le classi sono rappresentate da rettangoli suddivisi in tre sezioni:
\begin{enumerate}
	\item \textbf{Nome della classe}: indica il nome della classe;
	\item \textbf{Attributi}: elenco degli attributi della classe, con il relativo tipo di dato, seguendo il formato: 
	\begin{center}
		\textbf{Visibilità Nome: Tipo [Molteplicità] = Valore di default}\end{center}
	      \begin{itemize}
		      \item \textbf{Visibilità}: indica il livello di accesso agli attributi, che può essere:
		            \begin{itemize}
			            \item \textbf{+}: pubblico;
			            \item \textbf{-}: privato;
			            \item \textbf{\#}: protetto;
			            \item \textbf{\textasciitilde}: package.
		            \end{itemize}
		      \item \textbf{Nome}: nome dell'attributo. Deve essere rappresentativo, chiaro e deve seguire la notazione \textit{nomeAttributo: tipo}; \\ Se l'attributo è costante, il nome deve essere scritto in maiuscolo (es. \textit{PIGRECO: double});
		      \item \textbf{Molteplicità}: nel caso di una sequenza di elementi come liste o array, indica il numero di elementi presenti, se questa non fosse conosciuta si utilizza il simbolo \textit{*} (es \textit{tipoAttributo[*]});
		      \item \textbf{default}: valore di default dell'attributo.
	      \end{itemize}
	\item \textbf{Metodi}: descrivono il comportamento della classe, seguendo il formato: \\ \begin{center}\textbf{Visibilità Nome(parametri): Tipo di ritorno}\end{center}
	      \begin{itemize}
		      \item \textbf{Visibilità}: indica il livello di accesso ai metodi, che può essere:
		            \begin{itemize}
			            \item \textbf{+}: pubblico;
			            \item \textbf{-}: privato;
			            \item \textbf{\#}: protetto;
			            \item \textbf{\textasciitilde}: package.
		            \end{itemize}
		      \item \textbf{Nome}: nome del metodo. Deve essere rappresentativo, chiaro e deve seguire la notazione \textit{nomeMetodo(parametri): tipoRitorno};
		      \item \textbf{Parametri}: elenco dei parametri del metodo, separati tramite virgola. Ogni parametro deve seguire la notazione \textit{nomeParametro: tipo};
		      \item \textbf{Tipo di ritorno}: indica il tipo di dato restituito dal metodo.
	      \end{itemize}
\end{enumerate}

\textbf{Convenzioni sui metodi}
\begin{itemize}
	\item \textbf{I metodi getter, setter} e i \textbf{costruttori} non vengono inclusi fra i metodi;
	\item \textbf{I metodi statici} sono sottolineati;
	\item \textbf{I metodi astratti} sono scritti in corsivo.
	\item \textbf{L'assenza di attributi o metodi} in una classe determina l'assenza delle relative sezioni nel diagramma.
\end{itemize}
\textbf{Relazioni tra le classi}\\
Essenziali per rappresentare le interazioni e le dipendenze tra le varie componenti del sistema software, queste relazioni forniscono un quadro completo della struttura e del comportamento del sistema, consentendo agli sviluppatori di comprendere meglio come le classi si relazionano tra loro e di progettare un sistema coerente e ben strutturato. Di seguito sono descritte le principali relazioni tra le classi:
\begin{itemize}
	\item \textbf{Associazione}:  rappresenta una relazione tra due classi, indicando che un'istanza di una classe è correlata a un'istanza di un'altra classe. È raffigurata da una linea solida tra le classi coinvolte. La linea può includere etichette per indicare il nome dell'associazione, nonché molteplicità e ruoli per specificare la cardinalità e il ruolo delle classi nell'associazione.
		\begin{center}
			\includegraphics*[width=12cm]{../../../images/norme_di_progetto/associazioneClassi.png}
			\captionof{figure}{Diagramma delle classi - Associazione}
		\end{center}
	\newpage
	\item \textbf{Aggregazione}:  indica una relazione "tutto-parte" tra due classi, dove una classe è composta da una o più istanze di un'altra classe, ma le istanze possono esistere indipendentemente dalla classe principale. Composta da una linea con una freccia vuota che punta dalla parte composta (parte) al tutto (oggetto principale). La linea può includere un rombo vuoto sulla parte composta per indicare l'aggregazione.
		\begin{center}
			\includegraphics*[width=12cm]{../../../images/norme_di_progetto/aggregazioneClassi.png}
			\captionof{figure}{Diagramma delle classi - Aggregazione}
		\end{center}
	\item \textbf{Composizione}: simile all'aggregazione, ma indica una relazione più forte in cui l'esistenza delle parti dipende direttamente dall'oggetto principale. Una composizione è rappresentata da una linea con una freccia piena che punta dalla parte composta (parte) al tutto (oggetto principale). La linea può includere un rombo pieno sulla parte composta per indicare la composizione.
		\begin{center}
			\includegraphics*[width=10cm]{../../../images/norme_di_progetto/composizioneClassi.png}
			\captionof{figure}{Diagramma delle classi - Composizione}
		\end{center}
	\newpage
	\item \textbf{Ereditarietà o generalizzazione}: indica una relazione di specializzazione tra una classe superiore (superclasse) e una o più classi inferiori (sottoclassi). Le sottoclassi ereditano gli attributi e i metodi della superclasse e possono estenderli o modificarli. Viene effigiata da una linea con una freccia che punta dalla sottoclasse alla superclasse. La linea può includere una freccia vuota con la scritta "extends" per indicare la generalizzazione.
		\begin{center}
			\includegraphics*[width=10cm]{../../../images/norme_di_progetto/generalizzazioneClassi.png}
			\captionof{figure}{Diagramma delle classi - Generalizzazione}
		\end{center}
	\item \textbf{Dipendenza}: indica che una classe dipende dall'altra in un certo modo. Questo può significare che una classe utilizza o richiede i servizi di un'altra classe, ma non c'è un legame diretto tra le loro istanze. Una dipendenza è rappresentata da una linea tratteggiata che parte dalla classe dipendente e punta alla classe di cui dipende. La linea può includere una freccia vuota per indicare la direzione della dipendenza.
		\begin{center}
			\includegraphics*[width=12cm]{../../../images/norme_di_progetto/dipendenzaClassi.png}
			\captionof{figure}{Diagramma delle classi - Dipendenza}
		\end{center}
	\item \textbf{Realizzazione}:  indica che una classe implementa un'interfaccia o un contratto definito da un'altra classe. In altre parole, una classe realizza i metodi definiti da un'interfaccia o una classe astratta. Una realizzazione è raffigurata da una linea tratteggiata con una freccia vuota che punta dalla classe che implementa all'interfaccia o classe astratta che viene implementata.
	      \begin{center}
		      \includegraphics*[width=8cm]{../../../images/norme_di_progetto/realizzazioneClassi.png}
		      \captionof{figure}{Diagramma delle classi - Realizzazione}
	      \end{center}
\end{itemize}

\subsubsubsection{Design pattern}
I design pattern  sono soluzioni progettuali generiche e riutilizzabili per problemi comuni che si presentano durante lo sviluppo del software. Sono modelli architetturali, concetti o paradigmi consolidati, spesso espressi attraverso codice o diagrammi, che forniscono una guida per risolvere specifiche problematiche di progettazione software in modo efficiente ed efficace. la documentazione sui design pattern serve come punto di riferimento centrale per tutti gli sviluppatori coinvolti nel progetto, consentendo loro di comprendere rapidamente e facilmente come sono stati implementati determinati pattern nel codice. Questo è particolarmente utile durante le fasi di progettazione, sviluppo e manutenzione del software, in quanto fornisce una chiara visione della struttura architetturale del sistema e dei pattern utilizzati.
\subsubsubsection{Test}
La parte dei test all'interno del processo di sviluppo software è un'attività critica volta a garantire che il prodotto finale soddisfi i requisiti funzionali, prestazionali e di qualità previsti. Questa fase coinvolge diverse attività, che includono la pianificazione dei test, la progettazione dei casi di test, l'esecuzione dei test e l'analisi dei risultati. In questa sezione \hyperref[testing]{\textit{3.2.4}} vengono fornite descrizioni dettagliate delle varie tipologie di test e della terminologia associata.


\subsubsection{Codifica}
\subsubsubsection{Descrizione}
La parte di codifica, nota anche come implementazione, rappresenta una fase critica e fondamentale nel processo di sviluppo del software. Durante questa fase, gli sviluppatori assumono il compito di tradurre i requisiti funzionali e non funzionali, delineati durante le fasi di analisi e progettazione, in codice eseguibile. Questo processo richiede non solo competenze tecniche avanzate, ma anche una solida comprensione degli obiettivi del progetto e delle esigenze degli stakeholder.

\subsubsubsection{Obiettivi}
L'obiettivo principale della codifica è trasformare in modo accurato e efficiente i concetti astratti dei requisiti in istruzioni precise e comprensibili per il computer. Ciò implica la scrittura di codice pulito, ben strutturato e facilmente manutenibile, che sia in grado di soddisfare le esigenze funzionali del software e rispettare gli standard di qualità e le linee guida del progetto.

\subsubsubsection{Norme di codifica}
Le seguenti norme sono state formalizzate in questa maniera:
\begin{itemize}
	\item \textbf{nomi significativi}: i nomi delle variabili, delle costanti, delle classi e dei metodi devono essere significativi e rappresentativi della loro funzione, in modo da facilitare la comprensione del codice;
	\item \textbf{commenti}: il codice deve essere corredato da commenti chiari e significativi, che spiegano il funzionamento e lo scopo delle varie parti del codice, per facilitare la comprensione e la manutenzione;
	\item \textbf{indentazione e formattazione consistente}: il codice deve essere correttamente indentato e formattato, con l'uso di spazi e tabulazioni coerenti, per garantire una corretta leggibilità e comprensione;
	\item \textbf{gestione delle eccezioni}: il codice deve gestire correttamente le eccezioni e gli errori, fornendo messaggi di errore significativi e gestendo le situazioni anomale in modo appropriato;
	\item \textbf{riuso del codice}: il codice deve essere scritto in modo modulare e riutilizzabile, con la massima condivisione possibile di componenti e funzionalità tra i diversi moduli e classi;
	\item \textbf{test}: il codice deve essere testato e validato in modo approfondito, per garantire che soddisfi i requisiti funzionali e non funzionali e che sia privo di errori e bug;
	\item \textbf{sicurezza}: il codice deve essere scritto in modo sicuro, evitando vulnerabilità e falle di sicurezza, come l'iniezione di codice, la mancanza di controlli di input e la gestione non sicura delle password;
	\item \textbf{performance}: il codice deve essere ottimizzato per garantire prestazioni elevate e tempi di risposta rapidi, con l'uso corretto delle risorse e l'ottimizzazione dei cicli di elaborazione;
	\item \textbf{compatibilità}: il codice deve essere compatibile con le diverse piattaforme, sistemi operativi e browser, per garantire un'esperienza utente uniforme e coerente;
	\item \textbf{conformità ai principi SOLID}: il codice deve rispettare i principi SOLID, che promuovono la scrittura di codice pulito, modulare e manutenibile.
\end{itemize}

\subsubsubsection{Strumenti}
\textbf{Visual Studio Code}: è un ambiente di sviluppo integrato (IDE) sviluppato da Microsoft e adottato dal gruppo per lo sviluppo del software. Visual Studio Code offre funzionalità avanzate per la scrittura, la modifica e il debug del codice, con supporto per numerosi linguaggi di programmazione e framework.
\subsubsubsection{Metriche}
\begin{table}[!h] %todo aggiungere altre metriche se ci sono
	\centering
	\begin{tabular}{|c|c|}
		\hline
		\textbf{Metrica}                   & \textbf{Abbreviazione} \\
		\hline
		\hyperlink{subsection.6.2}{23M-CC} & Code Coverage          \\
		\hyperlink{subsection.6.2}{24M-BC} & Branch Coverage        \\
		\hyperlink{subsection.6.2}{25M-SC} & Statement Coverage     \\
		\hline
	\end{tabular}
	\caption{Metriche riguardanti l'attività di codifica}
	\label{tab:2}
\end{table}

\newpage
\subsubsection{Configurazione dell'ambiente di esecuzione}
\subsubsubsection{Docker}
L'utilizzo del file Docker garantisce che l'ambiente di sviluppo e produzione sia coerente e riproducibile. Questo approccio non solo assicura che le applicazioni funzionino correttamente in ogni fase del ciclo di vita, ma permette anche una gestione più efficiente delle dipendenze e delle configurazioni.\\
Di seguito un elenco delle best practice per la scrittura di file Docker:
\begin{itemize}
	\item \textbf{chiarezza e semplicità}: sono principi fondamentali nella scrittura di un Dockerfile. Questi principi aiutano a creare immagini Docker che sono facili da comprendere, mantenere e utilizzare.;
	\item \textbf{versionamento}: è una pratica essenziale per mantenere il controllo sulle diverse versioni del software e delle dipendenze all'interno di un Dockerfile. Questa pratica aiuta a garantire la riproducibilità delle build, a facilitare il debug e a mantenere un ambiente di produzione stabile;
	\item \textbf{sicurezza}: la sicurezza è una priorità cruciale nella costruzione di immagini Docker. Un Dockerfile sicuro riduce la superficie di attacco, protegge dalle vulnerabilità e garantisce l'integrità dell'applicazione;
	\item \textbf{efficienza}: nell'ottica di garantire tempi di risposta bassi, mantenendo comunque le pretazioni, i file Docker devono avere un utilizzo corretto delle risorse e una gestione accurata dei container;
	\item \textbf{gestione delle variabili d'ambiente}: è importante stabilire una pratica rigorosa che renda chiara la configurazione dell'applicazione all'interno del container. Le variabili d'ambiente sono fondamentali per la configurazione dinamica dell'applicazione, consentendo di adattare il comportamento dell'applicazione senza modificare direttamente il codice sorgente;
	\item \textbf{monitoraggio}: riveste un'importanza fondamentale per garantire una corretta comprensione del comportamento dell'applicazione, individuare eventuali problemi e monitorare le prestazioni in tempo reale. Questo processo permette agli sviluppatori e agli amministratori di sistema di ottenere una visione dettagliata delle attività dell'applicazione, della sua efficienza e di eventuali criticità;
	\item \textbf{layering}: ogni istruzione nel Dockerfile crea un nuovo layer all'interno dell'immagine Docker. La gestione efficiente di questi strati è cruciale poiché influisce direttamente sulle dimensioni dell'immagine Docker finale e sulla velocità di build;
	\item \textbf{riduzione delle dimensioni delle immagini}: la riduzione delle dimensioni delle immagini Docker è un aspetto fondamentale per migliorare l'efficienza di deployment, ridurre i tempi di trasferimento e ottimizzare l'utilizzo delle risorse del sistema;
	\item \textbf{documentazione}: fornire una documentazione esaustiva e chiara con un Dockerfile è essenziale per garantire la comprensione del suo funzionamento, facilitare la manutenzione e favorire la collaborazione tra i membri del team;
	\item \textbf{testing}: testare un Dockerfile in modo completo è cruciale per garantire che l'immagine Docker risultante sia configurata correttamente e funzioni come previsto. 
\end{itemize}

\subsubsubsection{Strumenti}
\begin{itemize}
	\item \textbf{Docker}: è una piattaforma open-source che permette di creare, distribuire e gestire applicazioni in ambienti di sviluppo e produzione utilizzando container leggeri e autonomi;
	\item \textbf{Visual Studio Code}: è un ambiente di sviluppo integrato (IDE) sviluppato da Microsoft e adottato dal gruppo per lo sviluppo del software. Visual Studio Code offre funzionalità avanzate per la scrittura, la modifica e il debug del codice, con supporto per numerosi linguaggi di programmazione e framework.
\end{itemize}
